import type { MockedResponse } from "@apollo/client/testing";
import { MockedProvider } from "@apollo/client/testing";
import { PureAbility } from "@casl/ability";
import { render, screen, waitFor } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import React from "react";
import { MemoryRouter } from "react-router-dom";

import { VulnerabilityModal } from ".";
import type { IVulnRowAttr } from "../types";
import { authzPermissionsContext } from "context/authz/config";
import { GET_VULN_ADDITIONAL_INFO } from "scenes/Dashboard/components/Vulnerabilities/AdditionalInfo/queries";
import { getLastTreatment } from "scenes/Dashboard/components/Vulnerabilities/UpdateDescription/utils";
import { GET_VULN_CODE_INFO } from "scenes/Dashboard/components/Vulnerabilities/VulnerabilityModal/queries";
import { formatDropdownField } from "utils/formatHelpers";
import { translate } from "utils/translations/translate";

describe("Vulnerability modal", (): void => {
  const mockedPermissions = new PureAbility<string>([
    { action: "api_mutations_remove_vulnerability_tags_mutate" },
    { action: "api_mutations_request_vulnerabilities_zero_risk_mutate" },
    { action: "api_mutations_update_vulnerability_treatment_mutate" },
    { action: "api_mutations_update_vulnerabilities_treatment_mutate" },
    { action: "api_resolvers_vulnerability_hacker_resolve" },
  ]);
  const mock: IVulnRowAttr = {
    advisories: null,
    assigned: "",
    externalBugTrackingSystem: null,
    findingId: "testgroup",
    groupName: "480857698",
    historicTreatment: [
      {
        acceptanceDate: "",
        acceptanceStatus: "",
        assigned: "usertreatment@test.test",
        date: "2019-07-05 09:56:40",
        justification: "test progress justification",
        treatment: "IN_PROGRESS",
        user: "usertreatment@test.test",
      },
    ],
    id: "89521e9a-b1a3-4047-a16e-15d530dc1340",
    lastStateDate: "2019-07-05 09:56:40",
    lastTreatmentDate: "2019-07-05 09:56:40",
    lastVerificationDate: null,
    organizationName: undefined,
    remediated: true,
    reportDate: "",
    rootNickname: "https:",
    severity: "3",
    severityTemporalScore: 3.0,
    source: "asm",
    specific: "specific-1",
    state: "VULNERABLE",
    stream: null,
    tag: "tag-1, tag-2",
    technique: "SCR",
    treatmentAcceptanceDate: "",
    treatmentAcceptanceStatus: "",
    treatmentAssigned: "",
    treatmentDate: "2019-07-05 09:56:40",
    treatmentJustification: "test progress justification",
    treatmentStatus: formatDropdownField("IN_PROGRESS"),
    treatmentUser: "usertreatment@test.test",
    verification: "Requested",
    vulnerabilityType: "inputs",
    where: "https://example.com/inputs",
    zeroRisk: null,
  };

  const mockQueryVulnAdditionalInfo: MockedResponse = {
    request: {
      query: GET_VULN_ADDITIONAL_INFO,
      variables: {
        canRetrieveHacker: true,
        vulnId: "89521e9a-b1a3-4047-a16e-15d530dc1340",
      },
    },
    result: {
      data: {
        vulnerability: {
          __typename: "Vulnerability",
          advisories: null,
          closingDate: null,
          commitHash: null,
          cycles: "1",
          efficacy: "0",
          hacker: "hacker@test.com",
          id: "89521e9a-b1a3-4047-a16e-15d530dc1340",
          lastReattackRequester: "",
          lastRequestedReattackDate: null,
          lastStateDate: "2020-09-05 03:23:23",
          lastTreatmentDate: "2019-07-05 09:56:40",
          reportDate: "",
          rootNickname: "",
          severity: "3",
          severityTemporalScore: 3.8,
          severityVector:
            "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:N/E:U/RL:O/RC:C",
          source: "test",
          specific: "specific-1",
          stream: null,
          technique: "SCR",
          treatmentAcceptanceDate: "",
          treatmentAcceptanceStatus: null,
          treatmentAssigned: "",
          treatmentChanges: "1",
          treatmentJustification: "test progress justification",
          treatmentStatus: "IN_PROGRESS",
          vulnerabilityType: "inputs",
          where: "https://example.com/inputs",
        },
      },
    },
  };

  const mockQueryVulnCodeInfo: MockedResponse = {
    request: {
      query: GET_VULN_CODE_INFO,
      variables: {
        vulnId: "89521e9a-b1a3-4047-a16e-15d530dc1340",
      },
    },
    result: {
      data: {
        vulnerability: {
          __typename: "Vulnerability",
          id: "89521e9a-b1a3-4047-a16e-15d530dc1340",
          snippet: { content: "print('Hello world!')", offset: 0 },
          specific: "specific-1",
        },
      },
    },
  };

  it("should return a function", (): void => {
    expect.hasAssertions();

    expect(typeof VulnerabilityModal).toBe("function");
  });

  it("should render vulnerability modal and keep info between tabs", async (): Promise<void> => {
    expect.hasAssertions();

    const onCloseAdditionalInfoModal: jest.Mock = jest.fn();
    const handleRefetchData: jest.Mock = jest.fn();
    render(
      <authzPermissionsContext.Provider value={mockedPermissions}>
        <MemoryRouter initialEntries={["/details"]}>
          <MockedProvider
            addTypename={false}
            mocks={[mockQueryVulnAdditionalInfo, mockQueryVulnCodeInfo]}
          >
            <VulnerabilityModal
              canDisplayHacker={true}
              canRemoveVulnsTags={true}
              canRequestZeroRiskVuln={true}
              canSeeSource={true}
              canUpdateVulnsTreatment={true}
              clearSelectedVulns={jest.fn()}
              closeModal={onCloseAdditionalInfoModal}
              currentRow={mock}
              findingId={"480857698"}
              groupName={"testgroup"}
              isFindingReleased={true}
              isModalOpen={true}
              refetchData={handleRefetchData}
            />
          </MockedProvider>
        </MemoryRouter>
      </authzPermissionsContext.Provider>
    );

    await waitFor((): void => {
      expect(
        screen.queryByText(
          translate.t(
            formatDropdownField(
              getLastTreatment(mock.historicTreatment).treatment
            )
          )
        )
      ).toBeInTheDocument();
    });

    expect(screen.getByText("test progress justification")).toBeInTheDocument();

    expect(screen.queryAllByRole("link")).toHaveLength(5);
    expect(
      screen.getByRole("link", {
        name: "searchFindings.tabVuln.contentTab.details.title",
      })
    ).toBeInTheDocument();
    expect(
      screen.getByRole("link", {
        name: "searchFindings.tabVuln.contentTab.severity.title",
      })
    ).toBeInTheDocument();
    expect(
      screen.getByRole("link", {
        name: "searchFindings.tabVuln.contentTab.code.title",
      })
    ).toBeInTheDocument();
    expect(
      screen.getByRole("link", {
        name: "searchFindings.tabVuln.contentTab.treatments.title",
      })
    ).toBeInTheDocument();
    expect(
      screen.getByRole("link", {
        name: "searchFindings.tabVuln.contentTab.tracking.title",
      })
    ).toBeInTheDocument();

    await userEvent.click(
      screen.getByRole("link", {
        name: "searchFindings.tabVuln.contentTab.treatments.title",
      })
    );

    await waitFor((): void => {
      expect(screen.getByRole("combobox", { name: "treatment" })).toHaveValue(
        "IN_PROGRESS"
      );
    });

    expect(screen.getByRole("textbox", { name: "justification" })).toHaveValue(
      ""
    );

    await userEvent.selectOptions(
      screen.getByRole("combobox", { name: "treatment" }),
      ["ACCEPTED"]
    );
    await userEvent.type(
      screen.getByRole("textbox", { name: "justification" }),
      "test justification to accepted treatment"
    );

    await userEvent.click(
      screen.getByRole("link", {
        name: "searchFindings.tabVuln.contentTab.details.title",
      })
    );

    await waitFor((): void => {
      expect(
        screen.queryByText(
          translate.t(
            formatDropdownField(
              getLastTreatment(mock.historicTreatment).treatment
            )
          )
        )
      ).toBeInTheDocument();
    });

    expect(screen.getByText("test progress justification")).toBeInTheDocument();
    expect(
      screen.queryByText("test justification to accepted treatment")
    ).not.toBeInTheDocument();

    await userEvent.click(
      screen.getByRole("link", {
        name: "searchFindings.tabVuln.contentTab.treatments.title",
      })
    );

    await waitFor((): void => {
      expect(screen.getByRole("combobox", { name: "treatment" })).toHaveValue(
        "ACCEPTED"
      );
    });

    expect(
      screen.queryByText("test progress justification")
    ).not.toBeInTheDocument();
    expect(
      screen.getByText("test justification to accepted treatment")
    ).toBeInTheDocument();

    await userEvent.click(screen.getByText("group.findings.report.modalClose"));
    await waitFor((): void => {
      expect(onCloseAdditionalInfoModal).toHaveBeenCalledTimes(1);
      expect(handleRefetchData).not.toHaveBeenCalled();
    });
  });
});
