import { useMutation } from "@apollo/client";
import type { ApolloError } from "@apollo/client";
import { Form, Formik } from "formik";
import type { GraphQLError } from "graphql";
import React, { useCallback } from "react";
import { useTranslation } from "react-i18next";
import { mixed, object } from "yup";

import { Select } from "components/Input";
import { FormGroup } from "components/Input/styles";
import { GET_ME_VULNERABILITIES_ASSIGNED_IDS } from "pages/home/dashboard/navbar/to-do/queries";
import { REMOVE_VULN_MUTATION } from "scenes/Dashboard/components/RemoveVulnerability/queries";
import type {
  IRemoveVulnAttr,
  IRemoveVulnerabilityFormProps,
} from "scenes/Dashboard/components/RemoveVulnerability/types";
import { GET_FINDING_HEADER } from "scenes/Dashboard/containers/Finding-Content/queries";
import { GET_FINDING_INFO } from "scenes/Dashboard/containers/Finding-Content/VulnerabilitiesView/queries";
import { GET_ME_VULNERABILITIES_ASSIGNED } from "scenes/Dashboard/containers/Tasks-Content/Vulnerabilities/queries";
import { Logger } from "utils/logger";
import { msgError } from "utils/notifications";

const RemoveVulnerabilityForm: React.FC<IRemoveVulnerabilityFormProps> = ({
  findingId,
  formRef,
  id,
  onRemoveVulnRes,
}: IRemoveVulnerabilityFormProps): JSX.Element => {
  const { t } = useTranslation();
  const handleDeleteResult = useCallback(
    (data: IRemoveVulnAttr): void => {
      onRemoveVulnRes(data);
    },
    [onRemoveVulnRes]
  );

  const handleDeleteError = useCallback(
    ({ graphQLErrors }: ApolloError): void => {
      graphQLErrors.forEach((error: GraphQLError): void => {
        if (
          error.message === "Invalid, you cannot remove a closed vulnerability"
        ) {
          msgError(t("deleteVulns.closedVuln"));
        } else {
          msgError(t("groupAlerts.errorTextsad"));
          Logger.warning("An error occurred deleting vulnerabilities", error);
        }
      });
    },
    [t]
  );

  const [removeVulnerability] = useMutation(REMOVE_VULN_MUTATION, {
    onCompleted: handleDeleteResult,
    onError: handleDeleteError,
    refetchQueries: [
      {
        query: GET_FINDING_HEADER,
        variables: {
          findingId,
        },
      },
      {
        query: GET_FINDING_INFO,
        variables: {
          findingId,
        },
      },
      { query: GET_ME_VULNERABILITIES_ASSIGNED },
      { query: GET_ME_VULNERABILITIES_ASSIGNED_IDS },
    ],
  });

  const handleDelete = useCallback(
    async (values: { justification: string }): Promise<void> => {
      await removeVulnerability({
        update: (cache, result): void => {
          if (result.data?.removeVulnerability.success === true) {
            const normalizedId = cache.identify({
              __typename: "Vulnerability",
              id,
            });
            cache.evict({ id: normalizedId });
            cache.gc();
          }
        },
        variables: {
          findingId,
          id,
          justification: values.justification,
        },
      });
    },
    [findingId, id, removeVulnerability]
  );

  const validations = object().shape({
    justification: mixed().required(t("validations.required")),
  });

  return (
    <Formik
      initialValues={{
        justification: "",
      }}
      innerRef={formRef}
      onSubmit={handleDelete}
      validationSchema={validations}
    >
      <Form id={"removeVulnerability"}>
        <FormGroup>
          <Select
            label={t("searchFindings.delete.justif.label")}
            name={"justification"}
          >
            <option value={""} />
            <option value={"DUPLICATED"}>
              {t("searchFindings.delete.justif.duplicated")}
            </option>
            <option value={"FALSE_POSITIVE"}>
              {t("searchFindings.delete.justif.falsePositive")}
            </option>
            <option value={"REPORTING_ERROR"}>
              {t("deleteVulns.reportingError")}
            </option>
          </Select>
        </FormGroup>
      </Form>
    </Formik>
  );
};

export { RemoveVulnerabilityForm };
