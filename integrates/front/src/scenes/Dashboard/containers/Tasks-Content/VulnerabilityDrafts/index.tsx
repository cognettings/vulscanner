import { useQuery } from "@apollo/client";
import type { PureAbility } from "@casl/ability";
import { faCheck, faSyncAlt } from "@fortawesome/free-solid-svg-icons";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import type { ColumnDef, ColumnFiltersState } from "@tanstack/react-table";
import _ from "lodash";
import React, {
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useState,
} from "react";
import { useTranslation } from "react-i18next";

import { GET_ME_VULNERABILITY_DRAFTS } from "./queries";
import type { IAction, IGetMeVulnerabilityDrafts, IGroupAction } from "./types";

import { SubmittedForm } from "../../Finding-Content/VulnerabilitiesView/HandleAcceptanceModal/SubmittedForm";
import { Button } from "components/Button";
import type { IFilter } from "components/Filter";
import { Filters, useFilters } from "components/Filter";
import { ButtonToolbarRow } from "components/Layout";
import { Modal } from "components/Modal";
import { filterDate } from "components/Table/filters/filterFunctions/filterDate";
import { formatLinkHandler } from "components/Table/formatters/linkFormatter";
import { Tooltip } from "components/Tooltip";
import { Can } from "context/authz/Can";
import {
  authzGroupContext,
  authzPermissionsContext,
} from "context/authz/config";
import { Have } from "context/authz/Have";
import { useDebouncedCallback, useStoredState, useTabTracking } from "hooks";
import { VulnComponent } from "scenes/Dashboard/components/Vulnerabilities";
import { statusFormatter } from "scenes/Dashboard/components/Vulnerabilities/Formatter";
import type { IVulnRowAttr } from "scenes/Dashboard/components/Vulnerabilities/types";
import { formatVulnerabilitiesTreatment } from "scenes/Dashboard/components/Vulnerabilities/utils";
import { GET_USER_ORGANIZATIONS_GROUPS } from "scenes/Dashboard/queries";
import type {
  IGetUserOrganizationsGroups,
  IOrganizationGroups,
} from "scenes/Dashboard/types";
import { Logger } from "utils/logger";
import { msgError } from "utils/notifications";

export const VulnerabilityDrafts: React.FC = (): JSX.Element => {
  const { t } = useTranslation();
  const [isConfirmModalOpen, setIsConfirmModalOpen] = useState(false);
  const attributesContext: PureAbility<string> = useContext(authzGroupContext);
  const permissionsContext: PureAbility<string> = useContext(
    authzPermissionsContext
  );
  const [columnFilters, setColumnFilters] = useStoredState<ColumnFiltersState>(
    "tblTodoVulnDrafts-columnFilters",
    [],
    localStorage
  );
  const [filters, setFilters] = useState<IFilter<IVulnRowAttr>[]>([
    {
      id: "organizationName",
      key: "organizationName",
      label: "Organization",
      type: "text",
    },
    {
      id: "groupName",
      key: "groupName",
      label: t("organization.tabs.groups.newGroup.name"),
      type: "text",
    },
    {
      id: "findingTitle",
      key: (row, value): boolean => {
        if (_.isEmpty(value)) return true;
        if (_.isEmpty(row.finding?.title)) return false;

        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return row.finding!.title.includes(value!);
      },
      label: t("searchFindings.tabVuln.vulnTable.vulnerabilityType.title"),
      type: "text",
    },
    {
      id: "hacker",
      key: "hacker",
      label: t("searchFindings.tabVuln.vulnTable.hacker"),
      type: "text",
    },
    {
      id: "sourceType",
      key: "sourceType",
      label: t("searchFindings.tabVuln.vulnTable.source"),
      selectOptions: [
        { header: t("searchFindings.tabVuln.machine"), value: "MACHINE" },
        { header: t("searchFindings.tabVuln.squad"), value: "SQUAD" },
      ],
      type: "select",
    },
    {
      id: "currentState",
      key: "state",
      label: t("searchFindings.tabVuln.vulnTable.status"),
      selectOptions: [
        { header: t("searchFindings.tabVuln.rejected"), value: "REJECTED" },
        { header: t("searchFindings.tabVuln.submitted"), value: "SUBMITTED" },
      ],
      type: "select",
      value: "SUBMITTED",
    },
    {
      id: "reportDate",
      key: "reportDate",
      label: t("searchFindings.tabVuln.vulnTable.reportDate"),
      type: "dateRange",
    },
    {
      id: "severity",
      key: "severityTemporalScore",
      label: t("searchFindings.tabDescription.severity"),
      type: "numberRange",
    },
  ]);
  const filtersMap: Record<string, IFilter<IVulnRowAttr>> = filters.reduce(
    (curr, filter): Record<string, IFilter<IVulnRowAttr>> => ({
      ...curr,
      [filter.id]:
        _.isEmpty(filter.value) &&
        _.every(filter.rangeValues, (value): boolean => value === "") &&
        _.every(
          filter.numberRangeValues,
          (value): boolean => value === undefined
        )
          ? undefined
          : filter,
    }),
    {}
  );
  const [debounceFiltersMap, setDebounceFiltersMap] =
    useState<Record<string, IFilter<IVulnRowAttr>>>(filtersMap);
  const updateDebouncedFilters = useCallback(
    (_filtersMap: Record<string, IFilter<IVulnRowAttr>>): void => {
      setDebounceFiltersMap(_filtersMap);
      // eslint-disable-next-line react-hooks/exhaustive-deps
    },
    [setDebounceFiltersMap]
  );
  const handleFilterDebounce = useDebouncedCallback(
    updateDebouncedFilters,
    800
  );
  useEffect((): void => {
    handleFilterDebounce(filtersMap);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [filters]);

  const { data: userData } = useQuery<IGetUserOrganizationsGroups>(
    GET_USER_ORGANIZATIONS_GROUPS,
    {
      fetchPolicy: "cache-first",
      onError: ({ graphQLErrors }): void => {
        graphQLErrors.forEach((error): void => {
          Logger.warning("An error occurred fetching user groups", error);
        });
      },
    }
  );

  const {
    data: meVulnerabilityDraftsData,
    refetch: refetchVulnerabilityDrafts,
    fetchMore: fethMoreVulnerabilityDrafts,
  } = useQuery<IGetMeVulnerabilityDrafts>(GET_ME_VULNERABILITY_DRAFTS, {
    fetchPolicy: "cache-first",
    onError: ({ graphQLErrors }): void => {
      graphQLErrors.forEach((error): void => {
        msgError(t("groupAlerts.errorTextsad"));
        Logger.warning(
          "An error occurred fetching vulnerability drafts",
          error
        );
      });
    },
    skip: _.isUndefined(userData),
    variables: {
      findingTitle: _.get(debounceFiltersMap, "findingTitle.value", undefined),
      first: 100,
      fromReportDate: _.get(filtersMap, "reportDate.rangeValues[0]", undefined),
      groupName: _.get(debounceFiltersMap, "groupName.value", undefined),
      hacker: _.get(debounceFiltersMap, "hacker.value", undefined),
      maxSeverityTemporalScore: _.get(
        filtersMap,
        "severity.numberRangeValues[1]",
        undefined
      ),
      minSeverityTemporalScore: _.get(
        filtersMap,
        "severity.numberRangeValues[0]",
        undefined
      ),
      organizationName: _.get(
        debounceFiltersMap,
        "organizationName.value",
        undefined
      ),
      sourceType: _.get(filtersMap, "sourceType.value", undefined),
      stateStatus: _.get(filtersMap, "currentState.value", undefined),
      toReportDate: _.get(filtersMap, "reportDate.rangeValues[1]", undefined),
    },
  });
  const size = meVulnerabilityDraftsData?.me.vulnerabilityDrafts.total;
  useTabTracking("Todos");
  const vulnerabilities = useMemo(
    (): IVulnRowAttr[] =>
      formatVulnerabilitiesTreatment({
        organizationsGroups:
          userData === undefined ? [] : userData.me.organizations,
        vulnerabilities: _.isUndefined(meVulnerabilityDraftsData)
          ? []
          : meVulnerabilityDraftsData.me.vulnerabilityDrafts.edges.map(
              (edge): IVulnRowAttr => edge.node
            ),
      }),
    [meVulnerabilityDraftsData, userData]
  );
  const vulnerabilitiesGroupName: string[] = useMemo(
    (): string[] =>
      Array.from(
        new Set(
          vulnerabilities.map((vulnerability: IVulnRowAttr): string =>
            vulnerability.groupName.toLowerCase()
          )
        )
      ),
    [vulnerabilities]
  );
  const changePermissions = useCallback(
    (groupName: string): void => {
      permissionsContext.update([]);
      if (userData !== undefined) {
        const recordPermissions: IGroupAction[] = _.flatten(
          userData.me.organizations.map(
            (organization: IOrganizationGroups): IGroupAction[] =>
              organization.groups.map(
                (group: IOrganizationGroups["groups"][0]): IGroupAction => ({
                  actions: group.permissions.map(
                    (action: string): IAction => ({
                      action,
                    })
                  ),
                  groupName: group.name,
                })
              )
          )
        );
        const filteredPermissions: IGroupAction[] = recordPermissions.filter(
          (recordPermission: IGroupAction): boolean =>
            recordPermission.groupName.toLowerCase() === groupName.toLowerCase()
        );
        if (filteredPermissions.length > 0) {
          permissionsContext.update(filteredPermissions[0].actions);
        }
      }
    },
    [permissionsContext, userData]
  );
  const pageInfo = _.isUndefined(meVulnerabilityDraftsData)
    ? { endCursor: "", hasNextPage: false }
    : meVulnerabilityDraftsData.me.vulnerabilityDrafts.pageInfo;

  const handleNextPage = useCallback(async (): Promise<void> => {
    if (pageInfo.hasNextPage) {
      await fethMoreVulnerabilityDrafts({
        variables: { after: pageInfo.endCursor },
      });
    }
  }, [pageInfo.hasNextPage, pageInfo.endCursor, fethMoreVulnerabilityDrafts]);

  const onGroupChange: () => void = (): void => {
    attributesContext.update([]);
    permissionsContext.update([]);
    if (userData !== undefined) {
      const currentPermissions: IAction[][] = _.flatten(
        userData.me.organizations.map(
          (organization: IOrganizationGroups): IAction[][] =>
            organization.groups.map(
              (group: IOrganizationGroups["groups"][0]): IAction[] =>
                group.permissions.map(
                  (action: string): IAction => ({
                    action,
                  })
                )
            )
        )
      );
      const groupsServicesAttributes: IOrganizationGroups["groups"] =
        userData.me.organizations.reduce(
          (
            previousValue: IOrganizationGroups["groups"],
            currentValue
          ): IOrganizationGroups["groups"] => [
            ...previousValue,
            ...currentValue.groups.filter((group): boolean =>
              vulnerabilitiesGroupName.includes(group.name.toLowerCase())
            ),
          ],
          []
        );
      const currentAttributes: string[] = Array.from(
        new Set(
          groupsServicesAttributes.reduce(
            (previous: string[], current): string[] => [
              ...previous,
              ...current.serviceAttributes,
            ],
            []
          )
        )
      );
      if (currentAttributes.length > 0) {
        attributesContext.update(
          currentAttributes.map((action: string): IAction => ({ action }))
        );
      }
      if (currentPermissions.length > 0 && currentPermissions[0].length > 0) {
        permissionsContext.update(
          Array.from(
            new Set(
              currentPermissions.reduce(
                (
                  selectedPermission: IAction[],
                  currentPermission: IAction[]
                ): IAction[] =>
                  currentPermission.length < selectedPermission.length
                    ? currentPermission
                    : selectedPermission,
                currentPermissions[0]
              )
            )
          )
        );
      }
    }
  };
  useEffect(onGroupChange, [
    attributesContext,
    permissionsContext,
    userData,
    vulnerabilitiesGroupName,
  ]);

  const columns: ColumnDef<IVulnRowAttr>[] = [
    {
      accessorKey: "organizationName",
      cell: (cell): JSX.Element => {
        const orgName =
          cell.row.original.organizationName === undefined
            ? ""
            : cell.row.original.organizationName;
        const link = `../orgs/${orgName}/groups/${cell.row.original.groupName}`;
        const text = cell.getValue<string>();

        return formatLinkHandler(link, text);
      },
      header: t("searchFindings.tabVuln.vulnTable.organization"),
      meta: { filterType: "select" },
    },
    {
      accessorKey: "groupName",
      cell: (cell): JSX.Element => {
        const orgName =
          cell.row.original.organizationName === undefined
            ? ""
            : cell.row.original.organizationName;
        const link = `../orgs/${orgName}/groups/${cell.row.original.groupName}`;
        const text = cell.getValue<string>();

        return formatLinkHandler(link, text);
      },
      header: t("organization.tabs.groups.newGroup.name"),
      meta: { filterType: "select" },
    },
    {
      accessorFn: (row): string | undefined => row.finding?.title,
      cell: (cell): JSX.Element => {
        const orgName =
          cell.row.original.organizationName === undefined
            ? ""
            : cell.row.original.organizationName;
        const findingId =
          cell.row.original.finding === undefined
            ? ""
            : cell.row.original.finding.id;
        const link =
          `../orgs/${orgName}/groups/${cell.row.original.groupName}` +
          `/vulns/${findingId}/locations`;
        const text = cell.getValue<string>();

        return formatLinkHandler(link, text);
      },
      header: t("searchFindings.tabVuln.vulnTable.vulnerabilityType.title"),
      id: "finding-title",
      meta: { filterType: "select" },
    },
    {
      accessorKey: "where",
      enableColumnFilter: false,
      header: t("searchFindings.tabVuln.vulnTable.where"),
    },
    {
      accessorKey: "specific",
      enableColumnFilter: false,
      header: t("searchFindings.tabVuln.vulnTable.specific"),
      sortingFn: "alphanumeric",
    },
    {
      accessorKey: "state",
      cell: (cell): JSX.Element => {
        const labels: Record<string, string> = {
          REJECTED: t("searchFindings.tabVuln.rejected"),
          SAFE: t("searchFindings.tabVuln.closed"),
          SUBMITTED: t("searchFindings.tabVuln.submitted"),
          VULNERABLE: t("searchFindings.tabVuln.open"),
        };

        return statusFormatter(labels[cell.getValue<string>()]);
      },
      header: t("searchFindings.tabVuln.vulnTable.status"),
      meta: { filterType: "select" },
    },
    {
      accessorKey: "reportDate",
      filterFn: filterDate,
      header: t("searchFindings.tabVuln.vulnTable.reportDate"),
      meta: { filterType: "dateRange" },
    },
    {
      accessorFn: (): string => "View",
      cell: (cell): JSX.Element => {
        const orgName =
          cell.row.original.organizationName === undefined
            ? ""
            : cell.row.original.organizationName;
        const findingId =
          cell.row.original.finding === undefined
            ? ""
            : cell.row.original.finding.id;
        const link =
          `../orgs/${orgName}/groups/${cell.row.original.groupName}` +
          `/vulns/${findingId}/evidence`;
        const text = cell.getValue<string>();

        return formatLinkHandler(link, text);
      },
      enableColumnFilter: false,
      header: "Evidence",
    },
    {
      accessorFn: (row): number => row.severityTemporalScore,
      header: t("searchFindings.tabDescription.severity"),
      id: "severity",
      meta: { filterType: "select" },
    },
    {
      accessorKey: "hacker",
      enableColumnFilter: false,
      header: t("searchFindings.tabVuln.vulnTable.hacker"),
    },
  ];

  const openConfirmModal = useCallback((): void => {
    setIsConfirmModalOpen(true);
  }, []);
  const closeConfirmModal = useCallback((): void => {
    setIsConfirmModalOpen(false);
  }, []);
  const refreshDrafts: () => void = useCallback(async (): Promise<void> => {
    await refetchVulnerabilityDrafts();
  }, [refetchVulnerabilityDrafts]);
  const filteredData = useFilters(
    vulnerabilities,
    filters.filter(
      (filter: IFilter<IVulnRowAttr>): boolean =>
        !["sourceType"].includes(filter.id)
    )
  );

  if (_.isUndefined(userData) || _.isEmpty(userData)) {
    return <div />;
  }

  return (
    <React.StrictMode>
      <div>
        <div>
          <VulnComponent
            changePermissions={changePermissions}
            columnDefaultVisibility={{
              organizationName: false,
              reportDate: false,
            }}
            columnFilterSetter={setColumnFilters}
            columnFilterState={columnFilters}
            columnToggle={true}
            columns={columns}
            csvColumns={[
              "groupName",
              "finding.title",
              "severityTemporalScore",
              "findingId",
              "hacker",
              "organizationName",
              "id",
              "where",
              "specific",
              "state",
              "reportDate",
              "lastStateDate",
            ]}
            csvHeaders={{
              "finding.title": t(
                "searchFindings.tabVuln.vulnTable.vulnerabilityType.title"
              ),
              findingId: t("searchFindings.tabVuln.vulnTable.vulnerabilityId"),
              groupName: t("organization.tabs.groups.newGroup.name"),
              hacker: t("searchFindings.tabVuln.vulnTable.hacker"),
              id: t("searchFindings.tabVuln.vulnTable.locationId"),
              lastStateDate: t("searchFindings.tabVuln.vulnTable.stateDate"),
              organizationName: t(
                "searchFindings.tabVuln.vulnTable.organization"
              ),
              reportDate: t("searchFindings.tabVuln.vulnTable.reportDate"),
              severityTemporalScore: t(
                "searchFindings.tabDescription.severity"
              ),
              specific: t("searchFindings.tabVuln.vulnTable.specific"),
              state: t("searchFindings.tabVuln.vulnTable.status"),
              where: t("searchFindings.tabVuln.vulnTable.where"),
            }}
            enableColumnFilters={false}
            exportCsv={true}
            extraButtons={
              <ButtonToolbarRow>
                <Button
                  id={"refresh-drafts"}
                  onClick={refreshDrafts}
                  variant={"secondary"}
                >
                  <FontAwesomeIcon icon={faSyncAlt} />
                </Button>
                <Have I={"is_continuous"}>
                  <Can do={"api_mutations_confirm_vulnerabilities_mutate"}>
                    <Tooltip
                      disp={"inline-block"}
                      id={
                        "searchFindings.tabDescription.validateLocations.tooltip.id"
                      }
                      tip={t(
                        "searchFindings.tabDescription.validateLocations.tooltip"
                      )}
                    >
                      <Button
                        disabled={
                          vulnerabilities.filter(
                            (vuln): boolean => vuln.state === "SUBMITTED"
                          ).length === 0
                        }
                        id={"start-review"}
                        onClick={openConfirmModal}
                        variant={"secondary"}
                      >
                        <React.Fragment>
                          <FontAwesomeIcon icon={faCheck} />
                          &nbsp;
                          {t(
                            "searchFindings.tabDescription.validateLocations.text"
                          )}
                        </React.Fragment>
                      </Button>
                    </Tooltip>
                  </Can>
                </Have>
              </ButtonToolbarRow>
            }
            filters={
              <Filters
                dataset={vulnerabilities}
                filters={filters}
                setFilters={setFilters}
              />
            }
            findingState={"VULNERABLE"}
            hasNextPage={pageInfo.hasNextPage}
            id={"draftsView"}
            isEditing={false}
            isFindingReleased={true}
            isRequestingReattack={false}
            isVerifyingRequest={false}
            onNextPage={handleNextPage}
            refetchData={refreshDrafts}
            size={size}
            vulnerabilities={filteredData}
          />
        </div>
      </div>
      {isConfirmModalOpen ? (
        <Modal
          onClose={closeConfirmModal}
          open={true}
          title={t("searchFindings.tabDescription.handleAcceptanceModal.title")}
        >
          <SubmittedForm
            changePermissions={changePermissions}
            displayGlobalColumns={true}
            findingId={undefined}
            groupName={undefined}
            onCancel={closeConfirmModal}
            refetchData={_.debounce(refreshDrafts, 1500)}
            vulnerabilities={vulnerabilities}
          />
        </Modal>
      ) : undefined}
    </React.StrictMode>
  );
};
