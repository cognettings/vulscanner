import { useMutation } from "@apollo/client";
import type { ApolloError } from "@apollo/client";
import { faPlus } from "@fortawesome/free-solid-svg-icons";
import type { FormikHelpers } from "formik";
import { Form, Formik } from "formik";
import type { GraphQLError } from "graphql";
import _ from "lodash";
// https://github.com/mixpanel/mixpanel-js/issues/321
// eslint-disable-next-line import/no-named-default
import { default as mixpanel } from "mixpanel-browser";
import React, {
  Fragment,
  StrictMode,
  useCallback,
  useEffect,
  useState,
} from "react";
import { useTranslation } from "react-i18next";
import { useParams } from "react-router-dom";
import { object, string } from "yup";

import { VulnerabilityPoliciesTable } from "./content";
import { ADD_ORGANIZATION_FINDING_POLICY } from "./queries";
import type {
  IVulnerabilityPolicies,
  IVulnerabilityPoliciesForm,
} from "./types";

import { GET_ORGANIZATION_POLICIES } from "../queries";
import { Button } from "components/Button";
import { Input, InputTags } from "components/Input";
import type { IFindingSuggestionData } from "scenes/Dashboard/containers/Group-Content/GroupFindingsView/types";
import { getFindingSuggestions } from "scenes/Dashboard/containers/Group-Content/GroupFindingsView/utils";
import { Logger } from "utils/logger";
import { msgError, msgSuccess } from "utils/notifications";

const tPath = "organization.tabs.policies.findings.";

export const VulnerabilityPolicies: React.FC<IVulnerabilityPolicies> = ({
  vulnerabilityPolicies,
  organizationId,
}: IVulnerabilityPolicies): JSX.Element => {
  const { organizationName } = useParams<{ organizationName: string }>();
  const { t } = useTranslation();
  const [suggestions, setSuggestions] = useState<string[]>([]);

  const [addOrganizationFindingPolicy, { loading: submitting }] = useMutation(
    ADD_ORGANIZATION_FINDING_POLICY,
    {
      onCompleted: (result: {
        addOrganizationFindingPolicy: { success: boolean };
      }): void => {
        if (result.addOrganizationFindingPolicy.success) {
          msgSuccess(
            t(`${tPath}addPolicies.success`),
            t("sidebar.newOrganization.modal.successTitle")
          );
        }
      },
      onError: (error: ApolloError): void => {
        error.graphQLErrors.forEach(({ message }: GraphQLError): void => {
          switch (message) {
            case "Exception - The finding name is invalid":
              msgError(t("validations.draftTitle"));
              break;
            case "Exception - The finding name policy already exists":
              msgError(t(`${tPath}errors.duplicateFinding`));
              break;
            default:
              msgError(t("groupAlerts.errorTextsad"));
              Logger.error("Error adding finding policy", message);
          }
        });
      },
      refetchQueries: [
        {
          query: GET_ORGANIZATION_POLICIES,
          variables: {
            organizationId,
          },
        },
      ],
    }
  );

  const handleSubmit = useCallback(
    async (
      values: IVulnerabilityPoliciesForm,
      formikHelpers: FormikHelpers<IVulnerabilityPoliciesForm>
    ): Promise<void> => {
      mixpanel.track("addNewOrgFindingPolicies", {
        Organization: organizationName,
      });
      await addOrganizationFindingPolicy({
        variables: {
          name: values.name,
          organizationName,
          tags: _.isEmpty(values.tags) ? undefined : values.tags.split(","),
        },
      });
      formikHelpers.resetForm();
    },
    [addOrganizationFindingPolicy, organizationName]
  );

  useEffect((): void => {
    async function fetchData(): Promise<void> {
      const findingSuggestions: IFindingSuggestionData[] =
        await getFindingSuggestions().catch(
          (error: Error): IFindingSuggestionData[] => {
            Logger.error("An error occurred getting title suggestions", error);

            return [];
          }
        );

      setSuggestions(
        _.sortBy(
          findingSuggestions.map(
            (suggestion: IFindingSuggestionData): string =>
              `${suggestion.code}. ${suggestion.title}`
          )
        )
      );
    }
    void fetchData();
  }, []);

  const validations = object().shape({
    name: string()
      .required(t("validations.required"))
      .matches(/^\d{3}\. .+/gu, t("validations.draftTitle"))
      .test(
        "validFindingTypology",
        t("validations.draftTypology"),
        (value?: string): boolean => {
          if (value === undefined || _.isEmpty(value)) {
            return false;
          }

          return suggestions.includes(value);
        }
      ),
  });

  return (
    <StrictMode>
      <Formik
        enableReinitialize={true}
        initialValues={{ name: "", tags: "" }}
        name={"addNewOrgFindingPolicies"}
        onSubmit={handleSubmit}
        validationSchema={validations}
      >
        {({ dirty, isValid }): JSX.Element => (
          <Form>
            <VulnerabilityPoliciesTable
              data={vulnerabilityPolicies}
              extraButtons={
                <Fragment>
                  <div className={"self-end"}>
                    <Input
                      label={t(`${tPath}form.finding`)}
                      list={"name-datalist"}
                      name={"name"}
                      suggestions={suggestions}
                    />
                  </div>
                  <div className={"self-start"}>
                    <div className={"flex items-end"}>
                      <InputTags label={t(`${tPath}form.tags`)} name={"tags"} />
                      <Button
                        disabled={!dirty || !isValid || submitting}
                        icon={faPlus}
                        type={"submit"}
                        variant={"secondary"}
                      />
                    </div>
                  </div>
                </Fragment>
              }
              organizationId={organizationId}
            />
          </Form>
        )}
      </Formik>
    </StrictMode>
  );
};
