from .schema import (
    ME,
)
import authz
from collections.abc import (
    Callable,
)
from custom_utils.validations_deco import (
    validate_all_fields_length_deco,
    validate_fields_deco,
)
from dataloaders import (
    Dataloaders,
)
from db_model.findings.utils import (
    format_finding,
)
from db_model.vulnerabilities.enums import (
    VulnerabilityStateStatus,
)
from db_model.vulnerabilities.types import (
    VulnerabilitiesConnection,
    VulnerabilityEdge,
)
from db_model.vulnerabilities.utils import (
    format_vulnerability,
)
from dynamodb.types import (
    Item,
    PageInfo,
)
from enum import (
    Enum,
)
from graphql.type.definition import (
    GraphQLResolveInfo,
)
from group_access.domain import (
    get_stakeholder_groups_names,
)
from more_itertools import (
    flatten,
)
from search.operations import (
    search,
)
from search.types import (
    BoolQuery,
)
from typing import (
    Any,
    NamedTuple,
)


class RangeOperator(Enum):
    GTE = "gte"
    LTE = "lte"


class FilterInfo(NamedTuple):
    attr_name: str
    formatter: Callable = lambda value: value


class RangeFilterInfo(NamedTuple):
    attr_name: str
    operator: RangeOperator


def _must_get_findings(**kwargs: Any) -> bool:
    related_filters = {"finding_title"}
    return any((kwargs.get(filter_name) for filter_name in related_filters))


def _must_get_severity_findings(**kwargs: Any) -> bool:
    related_filters = {
        "min_severity_temporal_score",
        "max_severity_temporal_score",
    }
    return any(
        kwargs.get(filter_name) is not None for filter_name in related_filters
    )


def _get_vulnerability_sk(finding_id: str) -> str:
    return f"FIN#{finding_id}"


def _get_finding_bool_filters() -> list[BoolQuery]:
    bool_filters: list[BoolQuery] = []
    draft_filter: BoolQuery = {
        "or_range_filters": [
            {
                "unreliable_indicators.unreliable_rejected_vulnerabilities": {
                    RangeOperator.GTE.value: 1
                }
            },
            {
                "unreliable_indicators.unreliable_submitted_vulnerabilities": {
                    RangeOperator.GTE.value: 1
                }
            },
        ]
    }
    bool_filters.append(draft_filter)
    return bool_filters


def _get_finding_range_filters(
    is_severity_query: bool = False, **kwargs: Any
) -> list[dict[str, dict]]:
    must_filters: list[dict[str, dict]] = []
    entity_attr_filters: dict[str, RangeFilterInfo] = {}
    if is_severity_query:
        entity_attr_filters.update(
            dict(
                min_severity_temporal_score=RangeFilterInfo(
                    attr_name="severity_score.temporal_score",
                    operator=RangeOperator.GTE,
                ),
                max_severity_temporal_score=RangeFilterInfo(
                    attr_name="severity_score.temporal_score",
                    operator=RangeOperator.LTE,
                ),
            )
        )
    for filter_name, info in entity_attr_filters.items():
        if (filter_value := kwargs.get(filter_name)) is not None:
            must_filters.append(
                {info.attr_name: {info.operator.value: filter_value}}
            )
    return must_filters


def _get_finding_must_filters(**kwargs: Any) -> list[dict[str, str]]:
    must_filters = []
    entity_attr_filters: dict[str, FilterInfo] = dict(
        group_name=FilterInfo(
            attr_name="group_name", formatter=lambda value: str(value).lower()
        ),
        finding_title=FilterInfo(attr_name="title"),
    )
    for filter_name, info in entity_attr_filters.items():
        if (filter_value := kwargs.get(filter_name)) and (
            formatted_filter_value := info.formatter(filter_value)
        ):
            must_filters.append({info.attr_name: formatted_filter_value})
    return must_filters


def _get_bool_filters(
    severity_vulnerability_sks: list[str], **kwargs: Any
) -> list[BoolQuery]:
    bool_filters: list[BoolQuery] = []
    entity_attr_filters: dict[tuple[str, ...], BoolQuery] = {
        ("min_severity_temporal_score", "max_severity_temporal_score"): {
            "or_range_filters": [
                {
                    "severity_score.temporal_score": {
                        RangeOperator.GTE.value: kwargs.get(
                            "min_severity_temporal_score"
                        ),
                        RangeOperator.LTE.value: kwargs.get(
                            "max_severity_temporal_score"
                        ),
                    }
                }
            ],
            "or_bool_filters": [
                {
                    "and_not_exists_filters": [
                        "severity_score.temporal_score"
                    ],
                    "and_exact_filters": {
                        "sk.keyword": severity_vulnerability_sks
                    },
                },
            ],
        }
    }
    for filter_names, bool_query in entity_attr_filters.items():
        if any(
            kwargs.get(filter_name) is not None for filter_name in filter_names
        ):
            bool_filters.append(bool_query)
    return bool_filters


def _get_exact_filters(
    groups_to_search: list[str], vulnerability_sks: list[str] | None
) -> Item:
    exact_filters = {
        "group_name": groups_to_search,
    }
    if vulnerability_sks is not None:
        exact_filters["sk.keyword"] = vulnerability_sks

    return exact_filters


def _get_must_filters(**kwargs: Any) -> list[dict[str, str]]:
    must_filters = []
    entity_attr_filters: dict[str, FilterInfo] = dict(
        group_name=FilterInfo(
            attr_name="group_name", formatter=lambda value: str(value).lower()
        ),
        hacker=FilterInfo(attr_name="created_by"),
        organization_name=FilterInfo(
            attr_name="organization_name",
            formatter=lambda value: str(value).lower(),
        ),
        state_status=FilterInfo(
            attr_name="state.status",
            formatter=lambda value: str(value).lower(),
        ),
        source_type=FilterInfo(
            attr_name="state.source",
            formatter=lambda value: "MACHINE" if value == "MACHINE" else None,
        ),
    )
    for filter_name, info in entity_attr_filters.items():
        if (filter_value := kwargs.get(filter_name)) and (
            formatted_filter_value := info.formatter(filter_value)
        ):
            must_filters.append({info.attr_name: formatted_filter_value})
    return must_filters


def _get_must_not_filters(**kwargs: Any) -> list[dict[str, str]]:
    must_not_filters: list[dict[str, VulnerabilityStateStatus | str]] = [
        {"state.status": VulnerabilityStateStatus.DELETED},
        {"state.status": VulnerabilityStateStatus.MASKED},
        {"state.status": VulnerabilityStateStatus.SAFE},
        {"state.status": VulnerabilityStateStatus.VULNERABLE},
    ]
    entity_attr_filters: dict[str, FilterInfo] = dict(
        source_type=FilterInfo(
            attr_name="state.source",
            formatter=lambda value: "MACHINE" if value == "SQUAD" else None,
        ),
    )
    for filter_name, info in entity_attr_filters.items():
        if (filter_value := kwargs.get(filter_name)) and (
            formatted_filter_value := info.formatter(filter_value)
        ):
            must_not_filters.append({info.attr_name: formatted_filter_value})
    return must_not_filters


def _get_range_filters(**kwargs: Any) -> list[dict[str, dict]]:
    must_filters: list[dict[str, dict]] = []
    entity_attr_filters: dict[str, RangeFilterInfo] = dict(
        from_report_date=RangeFilterInfo(
            attr_name="created_date", operator=RangeOperator.GTE
        ),
        to_report_date=RangeFilterInfo(
            attr_name="created_date", operator=RangeOperator.LTE
        ),
    )
    for filter_name, info in entity_attr_filters.items():
        if filter_value := kwargs.get(filter_name):
            must_filters.append(
                {info.attr_name: {info.operator.value: filter_value}}
            )
    return must_filters


@ME.field("vulnerabilityDrafts")
@validate_all_fields_length_deco(max_length=300)
@validate_fields_deco(
    [
        "finding_title",
        "group_name",
        "hacker",
        "organization_name",
        "state_status",
        "source_type",
    ]
)
async def resolve(
    parent: dict[str, Any], info: GraphQLResolveInfo, **kwargs: Any
) -> VulnerabilitiesConnection:
    stakeholder_email: str = str(parent["user_email"])
    loaders: Dataloaders = info.context.loaders
    test_groups_names = {
        group.name
        for group in flatten(
            await loaders.organization_groups.load_many(
                [
                    "0d6d8f9d-3814-48f8-ba2c-f4fb9f8d4ffa",
                    "a23457e2-f81f-44a2-867f-230082af676c",
                ]
            )
        )
    }
    stakeholder_groups_names = await get_stakeholder_groups_names(
        loaders, stakeholder_email, True
    )
    enforcer = await authz.get_group_level_enforcer(loaders, stakeholder_email)
    enforced_stakeholder_groups_names = {
        group_name
        for group_name in stakeholder_groups_names
        if enforcer(
            group_name, "api_resolvers_group_vulnerability_drafts_resolve"
        )
        if group_name not in test_groups_names
    }
    groups_to_search = [
        group_name
        for group_name in enforced_stakeholder_groups_names
        if group_name not in test_groups_names
    ]
    if not groups_to_search:
        return VulnerabilitiesConnection(
            edges=tuple(),
            page_info=PageInfo(has_next_page=False, end_cursor=""),
            total=0,
        )

    finding_results = (
        await search(
            exact_filters={"group_name": groups_to_search},
            should_filters=[
                {"state.status": "CREATED"},
                {"state.status": "REJECTED"},
                {"state.status": "SUBMITTED"},
                {"state.status": "APPROVED"},
            ],
            bool_filters=_get_finding_bool_filters(),
            must_filters=_get_finding_must_filters(**kwargs),
            must_not_filters=[
                {"state.status": "DELETED"},
                {"state.status": "MASKED"},
            ],
            index="findings",
            limit=1000,
            paginate=False,
        )
        if _must_get_findings(**kwargs)
        else None
    )
    vulnerability_sks = (
        [
            _get_vulnerability_sk(format_finding(item).id)
            for item in finding_results.items
        ]
        if finding_results
        else None
    )
    severity_finding_results = (
        await search(
            exact_filters={"group_name": groups_to_search},
            should_filters=[
                {"state.status": "CREATED"},
                {"state.status": "REJECTED"},
                {"state.status": "SUBMITTED"},
                {"state.status": "APPROVED"},
            ],
            bool_filters=_get_finding_bool_filters(),
            must_filters=_get_finding_must_filters(**kwargs),
            range_filters=_get_finding_range_filters(
                is_severity_query=True, **kwargs
            ),
            must_not_filters=[
                {"state.status": "DELETED"},
                {"state.status": "MASKED"},
            ],
            index="findings",
            limit=1000,
            paginate=False,
        )
        if _must_get_severity_findings(**kwargs)
        else None
    )
    severity_vulnerability_sks = (
        [
            _get_vulnerability_sk(format_finding(item).id)
            for item in severity_finding_results.items
        ]
        if severity_finding_results
        else []
    )
    results = await search(
        after=kwargs.get("after"),
        exact_filters=_get_exact_filters(groups_to_search, vulnerability_sks),
        must_filters=_get_must_filters(**kwargs),
        must_not_filters=_get_must_not_filters(**kwargs),
        range_filters=_get_range_filters(**kwargs),
        index="vulnerabilities",
        limit=kwargs.get("first", 100),
        bool_filters=_get_bool_filters(severity_vulnerability_sks, **kwargs),
    )
    return VulnerabilitiesConnection(
        edges=tuple(
            VulnerabilityEdge(
                cursor=results.page_info.end_cursor,
                node=format_vulnerability(item),
            )
            for item in results.items
        ),
        page_info=results.page_info,
        total=results.total,
    )
