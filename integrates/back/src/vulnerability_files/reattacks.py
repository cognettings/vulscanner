from collections.abc import (
    Sequence,
)
from custom_utils.vulnerabilities import (
    is_reattack_requested,
)
from dataloaders import (
    Dataloaders,
)
from db_model.vulnerabilities.enums import (
    VulnerabilityStateStatus,
)
from db_model.vulnerabilities.types import (
    Vulnerability,
)
from findings.domain.vulnerabilities import (
    verify_vulnerabilities,
)
from operator import (
    attrgetter,
)
from typing import (
    Any,
)


def _get_vulns_ids(vulns: list[Vulnerability]) -> set[str]:
    return set(map(attrgetter("id"), vulns))


def _get_vulns_to_reattack(
    last_status: VulnerabilityStateStatus,
    new_status: VulnerabilityStateStatus,
    vulns_in_db: list[Vulnerability | None],
    vulns_to_add: list[Vulnerability],
) -> list[Vulnerability]:
    return sorted(
        [
            vuln_to_add._replace(id=vuln_in_db.id)
            for vuln_in_db, vuln_to_add in zip(vulns_in_db, vulns_to_add)
            if (
                vuln_in_db
                and is_reattack_requested(vuln_in_db)
                and vuln_in_db.state.status == last_status
                and vuln_to_add.state.status == new_status
            )
        ],
        key=attrgetter("id"),
    )


async def process_reattack_from_uploaded_vulnerabilities(
    *,
    vulns_to_add: list[Vulnerability],
    vulns_in_db: Sequence[Vulnerability | None],
    finding_id: str,
    user_info: dict[str, str],
    loaders: Dataloaders,
    context: Any | None = None,
) -> set[str]:
    # Vulnerabilities that have a requested reattack are managed differently
    # They need to have their historic_verification modified so we avoid
    # open vulns being closed in this batch from being pending to reattack
    closed_vulns_to_reattack = _get_vulns_to_reattack(
        last_status=VulnerabilityStateStatus.VULNERABLE,
        new_status=VulnerabilityStateStatus.SAFE,
        vulns_in_db=list(vulns_in_db),
        vulns_to_add=vulns_to_add,
    )
    open_vulns_to_reattack = _get_vulns_to_reattack(
        last_status=VulnerabilityStateStatus.VULNERABLE,
        new_status=VulnerabilityStateStatus.VULNERABLE,
        vulns_in_db=list(vulns_in_db),
        vulns_to_add=vulns_to_add,
    )
    closed_vulns_ids = _get_vulns_ids(closed_vulns_to_reattack)
    open_vulns_ids = _get_vulns_ids(open_vulns_to_reattack)

    if closed_vulns_to_reattack:
        await verify_vulnerabilities(
            context=context,
            finding_id=finding_id,
            user_info=user_info,
            justification=(
                "The vulnerability was re-attacked and found to be closed"
            ),
            open_vulns_ids=[],
            closed_vulns_ids=list(closed_vulns_ids),
            vulns_to_close_from_file=closed_vulns_to_reattack,
            is_reattack_open=False,
            loaders=loaders,
        )

    if open_vulns_to_reattack:
        await verify_vulnerabilities(
            context=context,
            finding_id=finding_id,
            user_info=user_info,
            justification=(
                "The vulnerability was re-attacked and found to be still open"
            ),
            open_vulns_ids=list(open_vulns_ids),
            closed_vulns_ids=[],
            vulns_to_close_from_file=[],
            is_reattack_open=True,
            loaders=loaders,
        )

    return set.union(closed_vulns_ids, open_vulns_ids)
