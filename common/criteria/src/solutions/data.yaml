- title: SQL Injection
  need: Secure user input handling in database operations
  vulnerability_id: "012"
  context:
    - Java-based application
    - Using `JDBC` for database interaction
  solution:
    language: java
    insecure_code_example:
      text: |
        String userInput = request.getParameter("user_input");
        Statement statement = connection.createStatement();
        String query = "SELECT * FROM users WHERE name = '" + userInput + "'";
        ResultSet resultSet = statement.executeQuery(query);
      description: >
        In the above insecure code example, user input is directly used in an
        SQL query without any sanitization or validation. This exposes the
        application to SQL Injection attacks where a malicious user can input
        SQL code as their input and manipulate the SQL query to their advantage.
    steps:
      - Always use Prepared Statements or Stored Procedures when dealing with user input.
      - Never construct SQL queries by concatenating strings with user input.
      - Sanitize and validate user input to restrict unexpected behavior.
      - Regularly update and patch database software to prevent known SQL injection vulnerabilities.
    secure_code_example:
      text: |
        String userInput = request.getParameter("user_input");
        String query = "SELECT * FROM users WHERE name = ?";
        PreparedStatement preparedStatement = connection.prepareStatement(query);
        preparedStatement.setString(1, userInput);
        ResultSet resultSet = preparedStatement.executeQuery();
      description: >
        In this secure code example, a `PreparedStatement` is used instead of a Statement.
        This ensures that the user input is properly escaped and SQL Injection attacks are prevented.
        The user input cannot be interpreted as SQL code, so it does not allow for manipulation of the SQL query.
- title: SQL Injection
  vulnerability_id: "297"
  need: Protect the application against unauthorized data access, modification, or deletion via SQL Injection attacks.
  context:
    - This solution is applicable when using Python.
    - This solution is applicable when using MySQL database (via the `mysql-connector-python` library).
    - This solution is relevant when user inputs are directly used in SQL queries.
  solution:
    language: python
    insecure_code_example:
      text: |
        import mysql.connector

        username = input("Enter your username: ")
        password = input("Enter your password: ")

        conn = mysql.connector.connect(user='root', password='root', database='test')
        cursor = conn.cursor()

        cursor.execute(f"SELECT * FROM users WHERE username='{username}' AND password='{password}'")
        result = cursor.fetchone()
      description: >
        In this insecure code, the SQL query is constructed by directly inserting user inputs into the query string.
        This could lead to SQL Injection attacks, as an attacker could manipulate the SQL query through the input fields.
    steps:
      - >
        Use parameterized queries to handle SQL commands.
        This treats user inputs as literal values and not as part of the SQL command, which prevents SQL injection.
      - Always validate and sanitize user input before processing.
    secure_code_example:
      text: |
        import mysql.connector

        username = input("Enter your username: ")
        password = input("Enter your password: ")

        conn = mysql.connector.connect(user='root', password='root', database='test')
        cursor = conn.cursor()

        query = "SELECT * FROM users WHERE username=%s AND password=%s"
        cursor.execute(query, (username, password,))
        result = cursor.fetchone()
      description: >
        In this secure code, we use a parameterized query to substitute user inputs into the SQL query.
        This ensures that user inputs are treated as literals, preventing SQL Injection.
        However, additional measures such as input validation and sanitation should also be implemented for enhanced security.
- title: SQL Injection
  vulnerability_id: "001"
  need: Protect against unauthorized database access or data extraction via Blind SQL Injection attacks.
  context:
    - The solution is applicable when using C#.
    - The solution is applicable when using Microsoft SQL Server.
    - The solution is valid when user inputs are used to construct SQL queries directly.
  solution:
    language: csharp
    insecure_code_example:
      text: |
        string username = Console.ReadLine();
        string password = Console.ReadLine();

        using(SqlConnection connection = new SqlConnection("YourConnectionStringHere")) {
          connection.Open();

          string sql = "SELECT * FROM Users WHERE Username = '" + username +
            "' AND Password = '" + password + "'";
          SqlCommand command = new SqlCommand(sql, connection);

          SqlDataReader reader = command.ExecuteReader();
        }
      description: >
        In this insecure code, we are creating a SQL query by directly appending
        user inputs (`username` and `password`) into the query string.
        An attacker can manipulate these input fields and introduce malicious
        SQL commands leading to a Blind SQL Injection attack.
    steps:
      - Use parameterized queries to ensure the user inputs are treated as literal values and not as part of the SQL command. This will help prevent SQL injection.
      - Always validate and sanitize user inputs before using them in SQL queries.
    secure_code_example:
      text: |
        string username = Console.ReadLine();
        string password = Console.ReadLine();

        using (SqlConnection connection = new SqlConnection("YourConnectionStringHere"))
        {
            connection.Open();

            string sql = "SELECT * FROM Users WHERE Username = @username AND Password = @password";
            SqlCommand command = new SqlCommand(sql, connection);

            command.Parameters.AddWithValue("@username", username);
            command.Parameters.AddWithValue("@password", password);

            SqlDataReader reader = command.ExecuteReader();
        }
      description: >
        In this secure code, we are using parameterized queries, substituting user inputs into the SQL query as parameters.
        This ensures that the inputs are treated as literals, preventing SQL Injection.
- title: SQL Injection
  vulnerability_id: "146"
  need: Secure the application's data and prevent unauthorized extraction or manipulation of database information via SQL Injection attacks.
  context:
    - This solution is applicable when using Node.js.
    - This solution is applicable when using Oracle database (via the `oracledb` library).
    - This solution is relevant when user inputs are directly used in SQL queries.
  solution:
    language: nodejs
    insecure_code_example:
      text: |
        const oracledb = require('oracledb');
        let connection, result;
        let username = req.body.username;
        let password = req.body.password;

        try {
          connection = await oracledb.getConnection('YourConnectionStringHere');

          result = await connection.execute(
            `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`
          );
        } catch (err) {
          console.error(err);
        } finally {
          if (connection) {
            try {
              await connection.close();
            } catch (err) {
              console.error(err);
            }
          }
        }
      description: >
        In this insecure code, a SQL query is constructed by directly inserting user inputs into the query string.
        This opens up the potential for SQL Injection attacks as an attacker can manipulate the SQL query through the input fields.
    steps:
      - >
        Use bind variables in the SQL statement to ensure that user inputs are treated as
        literal values and not as part of the SQL command. This will help prevent SQL injection.
      - Always validate and sanitize user inputs before using them in SQL queries.
    secure_code_example:
      text: |
        const oracledb = require('oracledb');
        let connection, result;
        let username = req.body.username;
        let password = req.body.password;

        try {
          connection = await oracledb.getConnection('YourConnectionStringHere');

          result = await connection.execute(
            `SELECT * FROM users WHERE username = :username AND password = :password`,
            [username, password]
          );
        } catch (err) {
          console.error(err);
        } finally {
          if (connection) {
            try {
              await connection.close();
            } catch (err) {
              console.error(err);
            }
          }
        }
      description: >
        In this secure code, we use bind variables to substitute user inputs into the SQL query.
        This ensures that user inputs are treated as literals, preventing SQL Injection.
        However, additional input validation and sanitation methods should also be implemented for better security.
- title: SQL Injection
  vulnerability_id: "146"
  need: Secure the application from unauthorized data access or modification via SQL Injection attacks.
  context:
    - The solution is applicable when using Go.
    - The solution is applicable when using PostgreSQL database (via the `pq` package).
    - The solution is relevant when user inputs are directly used in SQL queries.
  solution:
    language: go
    insecure_code_example:
      text: |
        package main

        import (
            "database/sql"
            "fmt"
            _ "github.com/lib/pq"
        )

        func main() {
            db, err := sql.Open("postgres", "YourConnectionStringHere")
            if err != nil {
                panic(err)
            }
            defer db.Close()

            var username string
            fmt.Scanln(&username)

            var password string
            fmt.Scanln(&password)

            rows, err := db.Query(
              fmt.Sprintf(
                "SELECT * FROM users WHERE username = '%s' AND password = '%s'",
                username,
                password
                )
              )
            if err != nil {
                panic(err)
            }
            defer rows.Close()
        }
      description: >
        This insecure code is creating a SQL query by directly appending user
        inputs (`username` and `password`) into the query string.
        An attacker can manipulate these input fields and introduce malicious
        SQL commands, leading to SQL Injection attacks.
    steps:
      - Use parameterized queries, so user inputs are treated as literal values and not part of the SQL command, thus preventing SQL injection.
      - Always validate and sanitize user inputs before using them in SQL queries.
    secure_code_example:
      text: |
        package main

        import (
            "database/sql"
            "fmt"
            _ "github.com/lib/pq"
        )

        func main() {
            db, err := sql.Open("postgres", "YourConnectionStringHere")
            if err != nil {
                panic(err)
            }
            defer db.Close()

            var username string
            fmt.Scanln(&username)

            var password string
            fmt.Scanln(&password)

            rows, err := db.Query(
              "SELECT * FROM users WHERE username = $1 AND password = $2",
              username,
              password
              )
            if err != nil {
                panic(err)
            }
            defer rows.Close()
        }
      description: >
        This secure code is using parameterized queries, where user inputs are
        used as parameters in the SQL query, ensuring that the inputs are
        treated as literals, thus preventing SQL Injection.
- title: SQL Injection
  vulnerability_id: "146"
  need: Secure the application from unauthorized data access or modification via SQL Injection attacks.
  context:
    - The solution is applicable when using Erlang.
    - The solution is applicable when using PostgreSQL database (via the `epgsql` package).
    - The solution is relevant when user inputs are directly used in SQL queries.
  solution:
    language: erlang
    insecure_code_example:
      text: |
        -module(insecure).
        -export([start/0]).

        start() ->
            {ok, C} = epgsql:connect(
              "localhost",
              "user",
              "password",
              #{codecs => [epgsql_codec_text]}
            ),
            io:format("Please enter your username:~n"),
            {ok, [Username]} = io:fread(""),
            io:format("Please enter your password:~n"),
            {ok, [Password]} = io:fread(""),
            {ok, _, Rows} = epgsql:squery(C, lists:flatten(
              io_lib:format(
                "SELECT * FROM users WHERE username = '~s' AND password = '~s'",
                [Username, Password]
                )
              )
            ),
            io:format("Query Result: ~p~n", [Rows]),
            ok.
      description: >
        This insecure code constructs a SQL query by directly appending user inputs (`username` and `password`) into the query string.
        An attacker can manipulate these input fields and introduce malicious SQL commands, leading to SQL Injection attacks.
    steps:
      - Use parameterized queries, so user inputs are treated as literal values and not part of the SQL command, thus preventing SQL injection.
      - Always validate and sanitize user inputs before using them in SQL queries.
    secure_code_example:
      text: |
        -module(secure).
        -export([start/0]).

        start() ->
            {ok, C} = epgsql:connect(
              "localhost",
              "user",
              "password",
              #{codecs => [epgsql_codec_text]}
            ),
            io:format("Please enter your username:~n"),
            {ok, [Username]} = io:fread(""),
            io:format("Please enter your password:~n"),
            {ok, [Password]} = io:fread(""),
            {ok, _, Rows} = epgsql:equery(
              C, "SELECT * FROM users WHERE username = $1 AND password = $2",
              [Username, Password]
            ),
            io:format("Query Result: ~p~n", [Rows]),
            ok.
      description: >
        This secure code uses parameterized queries, where user inputs are used as parameters in the SQL query,
        ensuring that the inputs are treated as literals, thus preventing SQL Injection.
- title: SQL Injection
  need: Fetch user information from database using user-provided input
  vulnerability_id: "297"
  context:
    - The application is written in Kotlin.
    - The application that uses `JDBC` for database operations.
  solution:
    language: kotlin
    insecure_code_example:
      text: |
        import java.sql.DriverManager

        fun getUser(username: String) {
            val connection = DriverManager.getConnection(
              "jdbc:myDriver:myDatabase",
              "user",
              "password"
            )
            val statement = connection.createStatement()
            val resultSet = statement.executeQuery(
              "SELECT * FROM users WHERE username = '$username'"
            )
        }
      description: >
        The SQL query in this Kotlin code directly includes user-provided input
        in the SQL statement without any sanitization or parameterization.
        This can lead to SQL Injection attacks if malicious input is used.
    steps:
      - Avoid using user input directly in SQL queries.
      - Use parameterized statements or prepared statements which can prevent SQL injection attacks by automatically escaping special characters.
    secure_code_example:
      text: |
        import java.sql.DriverManager

        fun getUser(username: String) {
            val connection = DriverManager.getConnection(
              "jdbc:myDriver:myDatabase",
              "user",
              "password"
            )
            val statement = connection.prepareStatement("SELECT * FROM users WHERE username = ?")
            statement.setString(1, username)
            val resultSet = statement.executeQuery()
        }
      description: >
        This Kotlin code uses a PreparedStatement to parameterize the user input,
        ensuring it is treated as literal data rather than part of the SQL command,
        thereby preventing SQL Injection.
- title: SQL Injection
  need: Fetch user information from database using user-provided input
  vulnerability_id: "297"
  context:
    - The application is written in Scala.
    - The application that uses `JDBC` for database operations.
  solution:
    language: scala
    insecure_code_example:
      text: |
        import java.sql.DriverManager

        def getUser(username: String) {
          val connection = DriverManager.getConnection("jdbc:myDriver:myDatabase", "user", "password")
          val statement = connection.createStatement()
          val resultSet = statement.executeQuery(s"SELECT * FROM users WHERE username = '$username'")
        }
      description: >
        The SQL query in this Scala code directly includes user-provided input in the SQL
        statement without any sanitization or parameterization. This can lead to SQL Injection
        attacks if malicious input is used.
    steps:
      - Avoid using user input directly in SQL queries.
      - Use parameterized statements or prepared statements which can prevent SQL injection attacks by automatically escaping special characters.
    secure_code_example:
      text: |
        import java.sql.DriverManager

        def getUser(username: String) {
          val connection = DriverManager.getConnection(
            "jdbc:myDriver:myDatabase",
            "user",
            "password"
          )
          val statement = connection.prepareStatement(
            "SELECT * FROM users WHERE username = ?"
          )
          statement.setString(1, username)
          val resultSet = statement.executeQuery()
        }
      description: >
        This Scala code uses a PreparedStatement to parameterize the user input,
        ensuring it is treated as literal data rather than part of the SQL command,
        thereby preventing SQL Injection.
- title: SQL Injection
  need: Retrieve user information from a database based on user-provided input
  vulnerability_id: "297"
  context:
    - The application is written in Ruby.
    - The application that uses the `ActiveRecord` ORM for database operations.
  solution:
    language: ruby
    insecure_code_example:
      text: |
        class User < ActiveRecord::Base
        end

        def find_user(username)
          User.where("username = '#{username}'")
        end
      description: >
        The Ruby code above uses string interpolation to insert user input directly
        into an SQL query. This could allow an attacker to manipulate the SQL query
        and inject malicious SQL code, leading to a SQL Injection attack.
    steps:
      - Never insert user input directly into an SQL query.
      - Use query methods provided by the ORM that automatically escape user input, such as the hash syntax provided by ActiveRecord's `where` method.
    secure_code_example:
      text: |
        class User < ActiveRecord::Base
        end

        def find_user(username)
          User.where(username: username)
        end
      description: >
        In the secure code example, we are using ActiveRecord's hash syntax to perform the SQL query.
        This automatically escapes the user input, preventing SQL Injection attacks.
- title: SQL Injection
  need: Fetch data from the database using user-provided input
  vulnerability_id: "297"
  context:
    - The application is written in TypeScript.
    - The application that uses a SQL database for data storage.
  solution:
    language: typescript
    insecure_code_example:
      text: |
        import { createConnection } from "mysql";

        const connection = createConnection({
          host: "localhost",
          user: "user",
          password: "password",
          database: "test_db"
        });

        function getUser(userId: string) {
          connection.query(`SELECT * FROM users WHERE id = ${userId}`, (err, result) => {
            if (err) throw err;
            console.log(result);
          });
        }
      description: This TypeScript code uses string interpolation to insert user input directly into a SQL query. An attacker can manipulate the SQL query by injecting malicious SQL code through the userId input, leading to a SQL Injection attack.
    steps:
      - Avoid directly inserting user input into a SQL query.
      - Use parameterized queries or prepared statements to ensure user input is properly escaped and safe to use in a SQL query.
    secure_code_example:
      text: |
        import { createConnection } from "mysql";

        const connection = createConnection({
          host: "localhost",
          user: "user",
          password: "password",
          database: "test_db"
        });

        function getUser(userId: string) {
          connection.query('SELECT * FROM users WHERE id = ?', [userId], (err, result) => {
            if (err) throw err;
            console.log(result);
          });
        }
      description: >
        This TypeScript code uses parameterized queries to ensure user input is
        properly escaped and safe to use in a SQL query. This effectively mitigates the SQL Injection vulnerability.
- title: SQL Injection
  need: Fetch data from the database using user-provided input
  vulnerability_id: "297"
  context:
    - The application is written in PHP.
    - The application that uses a MySQL database for data storage.
  solution:
    language: php
    insecure_code_example:
      text: |
        <?php
        $servername = "localhost";
        $username = "username";
        $password = "password";
        $dbname = "database";

        // Create connection
        $conn = new mysqli($servername, $username, $password, $dbname);

        $id = $_GET['id'];

        // Check connection
        if ($conn->connect_error) {
          die("Connection failed: " . $conn->connect_error);
        }

        $sql = "SELECT * FROM Users WHERE id = $id";
        $result = $conn->query($sql);
        ?>
      description: >
        This PHP code uses user input directly in a SQL query.
        An attacker can manipulate the SQL query by injecting malicious SQL
        code through the 'id' input, leading to a SQL Injection attack.
    steps:
      - Avoid using user input directly in SQL queries.
      - Use prepared statements with parameterized queries to ensure user input is properly escaped and safe to use in a SQL query.
    secure_code_example:
      text: |
        <?php
        $servername = "localhost";
        $username = "username";
        $password = "password";
        $dbname = "database";

        // Create connection
        $conn = new mysqli($servername, $username, $password, $dbname);

        $id = $_GET['id'];

        // Check connection
        if ($conn->connect_error) {
          die("Connection failed: " . $conn->connect_error);
        }

        // Prepare SQL statement
        $stmt = $conn->prepare("SELECT * FROM Users WHERE id = ?");
        $stmt->bind_param("s", $id);

        // Execute the statement
        $stmt->execute();

        $result = $stmt->get_result();
        ?>
      description: >
        This PHP code uses prepared statements with parameterized queries to
        ensure user input is properly escaped and safe to use in a SQL query.
        This effectively mitigates the SQL Injection vulnerability.
- title: Remote Command Execution
  need: Secure handling of system command execution
  vulnerability_id: "004"
  context:
    - Java-based application
    - Using Java's `Runtime.exec()` method for system command execution
  solution:
    language: java
    insecure_code_example:
      text: |
        String userInput = request.getParameter("user_input");
        Runtime runtime = Runtime.getRuntime();
        Process process = runtime.exec("ping " + userInput);
      description: >
        In the above insecure code example, user input is directly used in a system command without any validation.
        This exposes the application to Remote Command Execution attacks where
        a malicious user can input command line arguments as their input and execute arbitrary commands on the system.
    steps:
      - Use standard library calls for the required functionality whenever possible.
      - Keep data used in the command outside of external control as much as possible.
      - Sanitize and validate user input to ensure special characters are escaped properly.
      - Keep your Java Runtime Environment up-to-date.
    secure_code_example:
      text: |
        String userInput = request.getParameter("user_input");
        if (isValidInput(userInput)) { // assuming this function validates if the user input is safe
            ProcessBuilder pb = new ProcessBuilder("ping", userInput);
            Process p = pb.start();
        }
      description: >
        In this secure code example, user input is first validated to check if it's safe.
        The ProcessBuilder is used instead of directly using `Runtime.exec()`.
        This allows better control over the arguments and helps prevent command injection attacks.
- title: Remote Command Execution
  need: Secure handling of system command execution
  vulnerability_id: "004"
  context:
    - Kotlin-based application
    - Using Kotlin's `Runtime.getRuntime().exec()` method for system command execution
  solution:
    language: kotlin
    insecure_code_example:
      text: |
        val userInput = readLine()
        val runtime = Runtime.getRuntime()
        val process = runtime.exec("ping " + userInput)
      description: >
        In the above insecure code example, user input is directly used in a system command
        without any validation. This exposes the application to Remote Command Execution attacks
        where a malicious user can input command line arguments as their input and execute arbitrary commands on the system.
    steps:
      - Use standard library calls for the required functionality whenever possible.
      - Keep data used in the command outside of external control as much as possible.
      - Sanitize and validate user input to ensure special characters are escaped properly.
      - Keep your Kotlin Runtime Environment up-to-date.
    secure_code_example:
      text: |
        val userInput = readLine()
        if (isValidInput(userInput)) { // assuming this function validates if the user input is safe
            val process = ProcessBuilder("ping", userInput).start()
        }
      description: >
        In this secure code example, user input is first validated to check if it's safe.
        The ProcessBuilder is used instead of directly using `Runtime.getRuntime().exec()`.
        This allows better control over the arguments and helps prevent command injection attacks.
- title: Remote Command Execution
  need: Secure handling of system command execution
  vulnerability_id: "004"
  context:
    - Go-based application
    - Using Go's os/exec package for system command execution
  solution:
    language: go
    insecure_code_example:
      text: |
        import (
          "os/exec"
        )

        func executeCommand(userInput string) {
          cmd := exec.Command("bash", "-c", userInput)
          cmd.Run()
        }
      description: >
        In the above insecure code example, user input is directly used in a
        system command without any validation. This exposes the application to
        Remote Command Execution attacks where a malicious user can input
        command line arguments as their input and execute arbitrary commands on the system.
    steps:
      - Use standard library calls for the required functionality whenever possible.
      - Keep data used in the command outside of external control as much as possible.
      - Sanitize and validate user input to ensure special characters are escaped properly.
      - Keep your Go environment up-to-date.
    secure_code_example:
      text: |
        import (
          "os/exec"
          "strings"
        )

        func executeCommand(userInput string) {
          if isValidInput(userInput) { // assuming this function validates if the user input is safe
            cmd := exec.Command("bash", "-c", strings.ReplaceAll(userInput, "'", "'\\''"))
            cmd.Run()
          }
        }
      description: >
        In this secure code example, user input is first validated to check if it's safe.
        The `strings.ReplaceAll` function is then used to escape any single quotes in the user input.
        This helps to prevent users from executing arbitrary commands.
- title: Remote Command Execution
  need: Secure handling of system command execution
  vulnerability_id: "004"
  context:
    - Node.js-based application
    - Using `child_process.exec()` method for system command execution
  solution:
    language: nodejs
    insecure_code_example:
      text: |
        var exec = require('child_process').exec;
        var userInput = req.query.userInput;

        exec('ls ' + userInput, function(err, data) {
          console.log(data);
        });
      description: >
        In the above insecure code example, user input is directly passed into
        the system command without any sanitization or validation.
        This exposes the application to the risk of Remote Command Execution,
        which can allow an attacker to execute arbitrary commands on the system.
    steps:
      - Avoid directly using user input in system commands whenever possible.
      - Sanitize and validate user input before using it in a command.
      - Use safer methods for command execution, such as the `child_process.execFile()` method in Node.js, which takes input as separate arguments and does not allow command chaining.
    secure_code_example:
      text: |
        var execFile = require('child_process').execFile;
        var userInput = req.query.userInput;

        execFile('ls', [userInput], function(err, data) {
          console.log(data);
        });
      description: >
        In the secure code example, the `child_process.execFile()` method is used
        instead of `exec()`. This method takes command arguments separately,
        preventing command injection attacks because special characters are not
        interpreted as command chaining or redirection.
- title: Remote Command Execution
  need: Execute system commands securely
  vulnerability_id: "004"
  context:
    - C#-based application
    - Usage of `System.Diagnostics.Process.Start()` method for system command execution
  solution:
    language: csharp
    insecure_code_example:
      text: |
        using System.Diagnostics;
        string userInput = Console.ReadLine();
        Process.Start("cmd.exe", "/C " + userInput);
      description: >
        In this insecure code, the user input is directly appended to the system
        command without any sanitization or validation. This allows an attacker
        to execute arbitrary commands on the system.
    steps:
      - Avoid using user input directly in system commands if possible.
      - Sanitize and validate user input before using it in a system command.
      - Use the overloaded `Process.Start()` method which takes command name and arguments separately, thus preventing command injection.
    secure_code_example:
      text: |
        using System.Diagnostics;
        string userInput = Console.ReadLine();
        Process.Start("cmd.exe", "/C dir", userInput);
      description: >
        In the secure code, the overloaded `Process.Start()` method is used.
        This method takes command and arguments separately, and does not allow the
        injection of additional commands, making it a safer alternative.
- title: Remote Command Execution
  need: Execute system commands based on user input
  vulnerability_id: "004"
  context:
    - Python-based application
  solution:
    language: python
    insecure_code_example:
      text: |
        import os
        user_input = input("Enter a directory: ")
        os.system("ls " + user_input)
      description: >
        In this insecure code, the user input is directly appended to the system
        command without any sanitization or validation. This allows an attacker
        to execute arbitrary commands on the system.
    steps:
      - Avoid using user input directly in system commands if possible.
      - Sanitize and validate user input before using it in a system command.
      - Use the `subprocess` module which provides more powerful facilities for spawning new processes and retrieving their results.
    secure_code_example:
      text: |
        import subprocess
        user_input = input("Enter a directory: ")
        subprocess.Popen(["ls", user_input])
      description: >
        In the secure code, the subprocess module is used. This method takes command
        and arguments separately, and does not allow the injection of additional commands,
        making it a safer alternative.
- title: Remote Command Execution
  need: Execute system commands using user-provided input
  vulnerability_id: "004"
  context:
    - Scala application that uses the `sys.process` package
  solution:
    language: scala
    insecure_code_example:
      text: |
        import sys.process._

        val user_input = scala.io.StdIn.readLine()
        s"$user_input".!
      description: >
        This Scala code snippet reads a line of user input and passes it to the
        system command executor. The danger here is that the user's input is not
        sanitized before it's executed, making this a potential point of exploitation
        for remote command execution if a malicious command is entered by the user.
    steps:
      - Avoid using user input directly in system commands. If it is absolutely necessary, be sure to sanitize the input.
      - Use Scala or Java's built-in functions to achieve the desired functionality whenever possible, rather than resorting to system command execution.
      - When sanitizing input, it's important to remember to escape or remove any characters or sequences that have special meaning to the system shell, such as '&' and ';'.
    secure_code_example:
      text: |
        import sys.process._

        val allowedChars = (('a' to 'z')
          ++ ('A' to 'Z')
          ++ ('0' to '9') ++ Seq(
            ' ',
            '-'
          )) // this can be changed according to your needs
        def sanitize(input: String): String = input.filter(allowedChars.contains)

        val user_input = scala.io.StdIn.readLine()
        val sanitized_input = sanitize(user_input)
        s"$sanitized_input".!
      description: >
        This Scala code snippet still executes system commands using user input,
        but it now sanitizes the input before doing so. It does this by only allowing
        certain characters in the command, reducing the risk of remote command execution.
- title: Remote Command Execution
  need: Execute system commands using user-provided input
  vulnerability_id: "004"
  context:
    - PHP script that uses the `system()` function
  solution:
    language: php
    insecure_code_example:
      text: |
        <?php
        $user_input = $_GET['user_input'];
        system($user_input);
        ?>
      description: >
        This PHP code snippet takes a user input through a GET request and
        passes it to the `system()` function, which executes it as a system command.
        This can lead to remote command execution if a malicious command is entered by the user.
    steps:
      - Use built-in PHP functions to achieve the desired functionality rather than executing system commands
      - If system commands must be used, sanitize the user input before executing it as a command
    secure_code_example:
      text: |
        <?php
        $user_input = escapeshellarg($_GET['user_input']);
        system($user_input);
        ?>
      description: >
        This code snippet sanitizes the user input with the `escapeshellarg()`
        function before passing it to the `system()` function,
        reducing the risk of remote command execution.
- title: Remote Command Execution
  need: Execute system commands using user-provided input
  vulnerability_id: "004"
  context:
    - TypeScript application using the child_process module
  solution:
    language: typescript
    insecure_code_example:
      text: |
        import { exec } from 'child_process';

        let user_input: string = process.argv[2];
        exec(user_input);
      description: >
        This TypeScript code snippet takes a user input through command line
        arguments and passes it to the `exec()` function, which executes it as a system command.
        This can lead to remote command execution if a malicious command is entered by the user.
    steps:
      - Use built-in TypeScript or Node.js functions to achieve the desired functionality rather than executing system commands
      - If system commands must be used, sanitize the user input before executing it as a command
    secure_code_example:
      text: |
        import { execFile } from 'child_process';

        let user_input: string = process.argv[2];
        execFile(user_input);
      description: >
        This code snippet uses the `execFile()` function instead of `exec()`,
        which doesn't allow command injection as it doesn't spawn a shell by default.
- title: Remote Command Execution
  need: Execute system commands using user-provided input
  vulnerability_id: "004"
  context:
    - Ruby script that uses the system
    - Ruby script that uses the `(backtick) method
  solution:
    language: ruby
    insecure_code_example:
      text: |
        user_input = gets.chomp
        system(user_input)
      description: >
        This Ruby code snippet reads a line of user input and passes it to the
        `system()` method, which executes it as a system command. This can lead to remote
        command execution if a malicious command is entered by the user.
    steps:
      - Use built-in Ruby functions or libraries to achieve the desired functionality rather than executing system commands
      - If system commands must be used, sanitize the user input before executing it as a command
    secure_code_example:
      text: |
        user_input = gets.chomp
        system(Shellwords.escape(user_input))
      description: >
        This code snippet sanitizes the user input using `Shellwords.escape` before
        passing it to the `system()` method, reducing the risk of remote command execution.
- title: Insecure Direct Object Reference (IDOR)
  need: Protect users' sensitive data by ensuring that one user cannot access another's data by simply modifying the key value that identifies it.
  vulnerability_id: "013"
  context:
    - When sensitive data is associated with specific user accounts and can be directly referenced.
    - When the server side does not validate if the requester has the right to access the requested data.
  solution:
    language: java
    insecure_code_example:
      text: |
        @GetMapping("/user/{id}")
        public ResponseEntity<User> getUser(@PathVariable String id) {
            User user = userRepository.findById(id).orElseThrow(
              () -> new ResourceNotFoundException("User not found")
            );
            return ResponseEntity.ok().body(user);
        }
      description: >
        In this code, any authenticated user can change the "id" in the URL to
        get any user's information. This is an insecure direct object reference
        vulnerability because the server does not verify if the requester has
        the right to access the requested user data.
    steps:
      - Validate that the requester has the right to access the requested data by checking the requester's session ID or authorization token.
      - For each request, cross-check the user's ID from the session with the ID in the URL to make sure that they are identical.
    secure_code_example:
      text: |
        @GetMapping("/user/{id}")
        public ResponseEntity < User > getUser(
          @PathVariable String id, Principal principal
        ) {
          User currentUser = userRepository.findByUsername(
            principal.getName()
          ).orElseThrow(() -> new ResourceNotFoundException("User not found"));
          if (!currentUser.getId().equals(id)) {
            throw new AccessDeniedException(
              "Not authorized to access this resource"
            );
          }
          User user = userRepository.findById(id).orElseThrow(
            () -> new ResourceNotFoundException("User not found")
          );
          return ResponseEntity.ok().body(user);
        }
      description: >
        In this secure code, we first fetch the user related to the current
        session using the principal object. If the ID of the user in session
        does not match the ID from the URL, an AccessDeniedException is thrown,
        preventing unauthorized data access.
- title: Insecure File Upload
  need: Safeguard the system from potentially malicious file uploads by validating the file's extension and content.
  vulnerability_id: "027"
  context:
    - When the system permits user file uploads.
    - When server side does not adequately validate the file's extension and content.
  solution:
    language: java
    insecure_code_example:
      text: |
        @PostMapping("/upload")
        public void uploadFile(@RequestParam("file") MultipartFile file) {
            try {
                File uploadedFile = new File(
                  uploadDirectory,
                  file.getOriginalFilename()
                );
                file.transferTo(uploadedFile);
            } catch (Exception e) {
                throw new FileUploadException("Could not upload file");
            }
        }
      description: >
        In this code, any file can be uploaded without any checks on its content or extension.
        This exposes the server to potential malicious file uploads, such as those with a double
        extension or those containing executable code.
    steps:
      - Validate the uploaded file's extension, making sure it only has one extension and is of an allowed type.
      - Ideally, validate the content of the file, ensuring it doesn't contain any potentially harmful code. This may involve using a third-party library or service, depending on your specific needs.
      - Ensure that the Content Type of the file corresponds with the file's extension before uploading it to the server.
    secure_code_example:
      text: |
        @PostMapping("/upload")
        public void uploadFile(@RequestParam("file") MultipartFile file) {
            String originalFilename = file.getOriginalFilename();
            String fileExtension = originalFilename.substring(
              originalFilename.lastIndexOf(".") + 1
            );

            // Check file extension
            if (!Arrays.asList("jpg", "png", "gif").contains(fileExtension)) {
                throw new FileUploadException("Invalid file extension");
            }

            // Check MIME type matches file extension
            String mimeType = file.getContentType();
            if (!mimeType.equals("image/" + fileExtension)) {
                throw new FileUploadException(
                "Content type does not match file extension"
              );
            }

            // Transfer file
            try {
                File uploadedFile = new File(
                  uploadDirectory,
                  originalFilename
                );
                file.transferTo(uploadedFile);
            } catch (Exception e) {
                throw new FileUploadException("Could not upload file");
            }
        }
      description: >
        In the secure code, we first validate the file's extension,
        only allowing the types `jpg`, `png`, and `gif`. Then, we ensure that
        the Content Type matches the file's extension. This mitigates the risk
        of a user disguising a malicious file as a harmless one by simply changing its extension.
- title: Improper Authorization Control
  need: Safeguard web services by ensuring that only authenticated users can access specific resources.
  vulnerability_id: "039"
  context:
    - When web services are provided to users without proper authorization control mechanisms.
    - When the server side does not validate the user's authentication status before giving them access to resources.
  solution:
    language: java
    insecure_code_example:
      text: |
        @GetMapping("/private/data")
        public ResponseEntity<String> getPrivateData() {
            // Get private data from the server
            String privateData = fetchPrivateData();
            return ResponseEntity.ok().body(privateData);
        }
      description: >
        This code allows anyone to access the endpoint "/private/data" and
        fetch private data from the server. There is no mechanism in place to ensure
        the user is authenticated before giving them access to the resource.
    steps:
      - Implement an authorization mechanism, such as session cookies or tokens.
      - Before processing the request, validate the session cookie or token to ensure the user is authenticated.
    secure_code_example:
      text: |
        @GetMapping("/private/data")
        public ResponseEntity<String> getPrivateData(Principal principal) {
            // Verify that the user is authenticated
            if (principal == null) {
                throw new UnauthorizedException("User is not authenticated");
            }

            // Get private data from the server
            String privateData = fetchPrivateData();
            return ResponseEntity.ok().body(privateData);
        }
      description: >
        In the secure code, before fetching the private data from the server,
        the Principal object is checked. If it's null, it means the user is not authenticated,
        so an UnauthorizedException is thrown. Otherwise, the server fetches the private data and returns it in the response.
- title: Insecure Cookie Generation
  need: Ensure that sensitive cookies are generated with appropriate security attributes, protecting them from being sent in plain text or disclosed by unauthorized users.
  vulnerability_id: "042"
  context:
    - When cookies are used for session management or storing sensitive user information.
    - When the application does not set appropriate security attributes while generating cookies.
  solution:
    language: java
    insecure_code_example:
      text: |
        @PostMapping("/login")
        public String login(
          @RequestParam("username") String username,
          @RequestParam("password") String password,
          HttpServletResponse response) {
          // Authenticate user...

          Cookie sessionCookie = new Cookie(
            "session",
            generateSessionId()
          );
          response.addCookie(sessionCookie);

          return "redirect:/home";
        }
      description: >
        This code creates a new session cookie whenever a user logs in. However, it does not set any security attributes on the cookie.
        As a result, the cookie could be sent over insecure channels in plain text or be accessed by client-side scripts,
        potentially leading to session hijacking or other security issues.
    steps:
      - Set the `Secure` attribute for the cookie, ensuring it is only sent over HTTPS.
      - Set the `HttpOnly` attribute, preventing client-side scripts from accessing the cookie.
    secure_code_example:
      text: |
        @PostMapping("/login")
        public String login(
          @RequestParam("username") String username,
          @RequestParam("password") String password,
          HttpServletResponse response) {
          // Authenticate user...

          Cookie sessionCookie = new Cookie(
            "session",
            generateSessionId()
          );
          sessionCookie.setSecure(true);
          sessionCookie.setHttpOnly(true);
          response.addCookie(sessionCookie);

          return "redirect:/home";
        }
      description: >
        The secure code includes setting of `Secure and `HttpOnly` attributes on the session cookie.
        The `Secure` attribute ensures that the cookie is only sent over HTTPS, while the `HttpOnly`
        attribute prevents client-side scripts from accessing the cookie, mitigating the risk of session
        hijacking through cross-site scripting (XSS) attacks.
- title: Weak Credentials and Hash
  need: Ensure password security by using strong hashing algorithms with adequate length for password storage.
  vulnerability_id: "051"
  context:
    - When the system uses weak or broken hashing algorithms for password storage.
    - When the system uses hashing algorithms that generate shorter hashes, reducing their security.
  solution:
    language: java
    insecure_code_example:
      text: |
        import java.security.MessageDigest;

        public String hashPassword(String password) {
            try {
                MessageDigest md = MessageDigest.getInstance("MD5");
                md.update(password.getBytes());
                byte[] bytes = md.digest();

                // Convert it to hexadecimal
                StringBuilder sb = new StringBuilder();
                for (byte b : bytes) {
                    sb.append(Integer.toString((b & 0xff) + 0x100, 16).substring(1));
                }

                return sb.toString();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
      description: >
        This code hashes a password using the `MD5` algorithm, which is considered insecure due
        to its vulnerability to collision attacks. In addition, `MD5` generates a hash of only 128 bits,
        which is less than the recommended minimum size of 256 bits.
    steps:
      - Use a secure hashing algorithm, such as SHA-256, which provides a longer, more secure hash.
      - Consider using a salt in combination with the password to further enhance security.
    secure_code_example:
      text: |
        import java.security.MessageDigest;

        public String hashPassword(String password, String salt) {
            try {
                MessageDigest md = MessageDigest.getInstance("SHA-256");
                md.update((salt + password).getBytes());
                byte[] bytes = md.digest();

                // Convert it to hexadecimal
                StringBuilder sb = new StringBuilder();
                for (byte b : bytes) {
                    sb.append(Integer.toString((b & 0xff) + 0x100, 16).substring(1));
                }

                return sb.toString();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
      description: >
        The secure code hashes the password using the `SHA-256` algorithm, which is more
        secure and generates a 256-bit hash. Additionally, it uses a salt combined with
        the password before hashing, making the hash even harder to crack by adding randomness.
- title: Validating Data Authenticity of Images
  need: To ensure that user-provided URLs for profile images lead to valid images and prevent potential redirects or Cross-Site Request Forgery (CSRF)
  vulnerability_id: "327"
  context:
    - When developing a Java web application that allows users to upload images via URLs
  solution:
    language: java
    insecure_code_example:
      text: |
        public class UserProfile {
            private String imageURL;

            public void setImageURL(String imageURL) {
                this.imageURL = imageURL;
            }

            public String getImageURL() {
                return this.imageURL;
            }
        }
      description: The UserProfile class in the insecure code does not validate the imageURL when setting it. This can allow an attacker to set imageURL to an invalid URL, or one that leads to a malicious site.
    steps:
      - Implement URL validation when setting the imageURL.
      - Make sure that the URL is absolute, has a valid syntax, and points to an actual image file.
      - For additional security, consider retrieving the image and serving it from your own server.
    secure_code_example:
      text: |
        public class UserProfile {
            private String imageURL;

            public void setImageURL(
              String imageURL
            ) throws MalformedURLException {
                URL url = new URL(imageURL); // Check URL syntax

                // Check that the URL points to an image
                String contentType = URLConnection.guessContentTypeFromName(
                  url.getPath()
                );
                if (contentType == null || !contentType.startsWith("image")) {
                    throw new IllegalArgumentException(
                      "URL must point to an image file"
                    );
                }

                this.imageURL = imageURL;
            }

            public String getImageURL() {
                return this.imageURL;
            }
        }
      description: >
        The UserProfile class in the secure code validates the imageURL before setting it.
        It ensures that the URL has a valid syntax and points to an image file.
        This prevents an attacker from setting imageURL to an invalid or malicious URL.
- title: Validating Data Authenticity via Checksum Verification
  need: To ensure the integrity of resources loaded from external servers has not been compromised.
  vulnerability_id: "355"
  context:
    - When developing a Java application that involves downloading resources from external servers.
  solution:
    language: java
    insecure_code_example:
      text: |
        import java.io.InputStream;
        import java.net.URL;
        import java.nio.file.Files;
        import java.nio.file.Paths;

        public class DownloadResource {
            public void download(
              String resourceURL,
              String destinationPath
            ) throws Exception {
                URL url = new URL(resourceURL);
                InputStream in = url.openStream();
                Files.copy(in, Paths.get(destinationPath));
            }
        }
      description: >
        This code simply downloads a resource from an external server and saves
        it to a local file without verifying the integrity of the downloaded resource.
    steps:
      - Calculate the checksum of the downloaded resource.
      - Compare the calculated checksum with the expected checksum.
      - If the checksums do not match, discard the resource as it may have been tampered with.
    secure_code_example:
      text: |
        import java.io.InputStream;
        import java.net.URL;
        import java.nio.file.Files;
        import java.nio.file.Paths;
        import java.security.MessageDigest;

        public class DownloadResource {
            public void download(
              String resourceURL,
              String destinationPath,
              String expectedChecksum
            ) throws Exception {
                URL url = new URL(resourceURL);
                InputStream in = url.openStream();
                MessageDigest md = MessageDigest.getInstance("SHA-256");

                byte[] data = in.readAllBytes();
                byte[] hash = md.digest(data);

                StringBuilder sb = new StringBuilder();
                for (byte b : hash) {
                    sb.append(String.format("%02x", b));
                }

                if (!sb.toString().equals(expectedChecksum)) {
                    throw new IllegalArgumentException(
                      "Checksum does not match"
                    );
                }

                Files.copy(in, Paths.get(destinationPath));
            }
        }
      description: >
        The secure code calculates the SHA-256 checksum of the downloaded
        resource and compares it with the expected checksum.
        If they do not match, it throws an exception and does not save the
        file, protecting against corrupted or tampered resources.
- title: Insecure Token Generation
  need: To securely generate and manage session tokens, protecting against brute force attacks and ensuring data integrity.
  vulnerability_id: "078"
  context:
    - Developing a Java web application with a need for session management.
  solution:
    language: java
    insecure_code_example:
      text: |
        import java.util.Date;

        public class Token {
            private static long tokenCount = 0;

            public static String generateToken(String username) {
                Date date = new Date();
                String token = username + date.toString() + tokenCount;
                tokenCount++;
                return token;
            }
        }
      description: >
        This insecure code generates a predictable token by concatenating a username,
        the current date and time, and a counter. An attacker might predict or brute-force
        these tokens because they don't contain random components.
    steps:
      - Use a secure random generator to add randomness to the token.
      - Do not embed sensitive information directly into the token.
    secure_code_example:
      text: |
        import java.security.SecureRandom;
        import java.util.Base64;

        public class Token {
            private static final SecureRandom secureRandom =
              new SecureRandom(); //threadsafe
            private static final Base64.Encoder base64Encoder =
              Base64.getUrlEncoder(); //threadsafe

            public static String generateNewToken() {
                byte[] randomBytes = new byte[24];
                secureRandom.nextBytes(randomBytes);
                return base64Encoder.encodeToString(randomBytes);
            }
        }
      description: >
        The secure code generates a session token using a secure random
        generator, and it doesn't include sensitive data such as usernames in
        the token itself.
- title: Securing Sensitive Information in Transit
  need: To prevent sensitive information from being exposed through URL parameters.
  vulnerability_id: "030"
  context:
    - Java web applications using HTTP GET requests for transferring sensitive data.
  solution:
    language: java
    insecure_code_example:
      text: |
        @GetMapping("/user")
        public ModelAndView getUser(
          @RequestParam String username,
          @RequestParam String password
        ) {
          // authenticate user
          // return some data
        }
      description: >
        The above code receives the username and password as URL parameters,
        which could expose sensitive information.
    steps:
      - Replace HTTP GET requests with HTTP POST requests when transferring sensitive information.
      - Use HTTPS protocol to encrypt the information in transit.
    secure_code_example:
      text: |
        @PostMapping("/user")
        public ModelAndView getUser(
          @RequestParam String username,
          @RequestParam String password
        ) {
          // authenticate user
          // return some data
        }
      description: >
        The above code receives the username and password as parameters in the
        body of a POST request, which is more secure as it doesn't expose
        sensitive data in URLs. Make sure the server is configured to use HTTPS.
- title: Secure Server-Side Requests
  need: To securely handle server-side requests, protecting against Server-Side Request Forgery (SSRF).
  vulnerability_id: "100"
  context:
    - Developing a Java web application that needs to make outbound HTTP requests.
  solution:
    language: java
    insecure_code_example:
      text: |
        import java.net.HttpURLConnection;
        import java.net.URL;

        public class Service {
            public String fetchData(String externalUrl) throws Exception {
                URL url = new URL(externalUrl);
                HttpURLConnection conn =
                  (HttpURLConnection) url.openConnection();
                // Rest of the logic to fetch data
            }
        }
      description: >
        This insecure code takes an external URL as input and makes a
        server-side HTTP request to it. This opens up the possibility for
        Server-Side Request Forgery (SSRF) because an attacker can provide URLs
        of their choosing.
    steps:
      - Validate the provided URLs, ensuring they fall within the acceptable and safe range.
      - If possible, limit outbound connections from the server.
    secure_code_example:
      text: |
        import java.net.HttpURLConnection;
        import java.net.URL;

        public class Service {
            private static final String ALLOWED_DOMAIN = "https://www.allowed-domain.com";

            public String fetchData(String path) throws Exception {
                URL url = new URL(ALLOWED_DOMAIN + path);
                HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                // Rest of the logic to fetch data
            }
        }
      description: >
        The secure code does not allow the user to provide an arbitrary URL.
        Instead, it only accepts a path which is appended to a predefined and
        trusted domain. This approach prevents the possibility of SSRF.
- title: Insecure External Redirections
  need: To perform user redirections in a secure manner, avoiding the possibility of uncontrolled external site redirect vulnerability.
  vulnerability_id: "156"
  context:
    - Developing a web application in Java that involves user redirection to other parts of the application or external websites.
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.http.HttpServletResponse;

        public void redirectTo(
          String url,
          HttpServletResponse response
        ) throws IOException {
            response.sendRedirect(url);
        }
      description: >
        In this insecure example, the 'url' parameter is coming directly from
        the user input, meaning an attacker could provide a malicious URL to
        trick users, leading to potential phishing attacks.
    steps:
      - Do not rely on user input for the destination of the redirection.
      - Create a list of valid URLs for redirection, and validate user input against this list.
    secure_code_example:
      text: |
        import javax.servlet.http.HttpServletResponse;

        public void redirectTo(
          String page,
          HttpServletResponse response
        ) throws IOException {
            String base = "https://www.safe-site.com";
            String safeUrl = base + "/" + page;
            response.sendRedirect(safeUrl);
        }
      description: >
        In this secure example, we ensure that the base URL is a known safe
        site, and the redirection only allows appending of specific pages,
        drastically reducing the chances of redirecting to a malicious site.
- title: Clickjacking Attacks
  need: To prevent a webpage from being displayed in a frame or iframe, which helps to protect against clickjacking attacks.
  vulnerability_id: "360"
  context:
    - Developing a web application in Java that sends HTTP responses.
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.http.HttpServletResponse;

        public void setHeaders(HttpServletResponse response) {
            // Other headers...
        }
      description: >
        This code does not include any directives to prevent the page from
        being embedded in an iframe. This leaves the application vulnerable to
        clickjacking attacks.
    steps:
      - "Use the `X-Frame-Options` HTTP header to indicate whether or not a browser should be allowed to render a page in a `frame` or `iframe`."
      - "The X-Frame-Options header can have the following values: `DENY`, `SAMEORIGIN`, or `ALLOW-FROM` uri."
      - The "Content-Security-Policy" header with the "frame-ancestors" directive can also be used for more granular control.
    secure_code_example:
      text: |
        import javax.servlet.http.HttpServletResponse;

        public void setHeaders(HttpServletResponse response) {
            // Other headers...
            response.setHeader("X-Frame-Options", "DENY");
            response.setHeader("Content-Security-Policy", "frame-ancestors 'none'");
        }
      description: >
        This secure example includes the "X-Frame-Options" and
        "Content-Security-Policy" headers with a secure configuration.
        This helps to protect against clickjacking attacks by indicating that
        the page should not be displayed within a frame.
- title: Detecting Rooted Devices
  need: To prevent the application from running on a rooted Android device, which may be compromised and could result in data leakage or unauthorized actions.
  vulnerability_id: "048"
  context:
    - Developing an Android application in Java.
  solution:
    language: java
    insecure_code_example:
      text: |
        public class MainActivity extends AppCompatActivity {

            @Override
            protected void onCreate(Bundle savedInstanceState) {
                super.onCreate(savedInstanceState);
                setContentView(R.layout.activity_main);
                // Other code...
            }
        }
      description: >
        The application starts without checking whether the device is rooted,
        making it vulnerable to possible attacks on rooted devices.
    steps:
      - Add a method to check for root access by looking for signs that are typically present on rooted devices, such as the presence of certain files.
      - Call this method during the creation of the main activity.
    secure_code_example:
      text: |
        import java.io.File;

        public class MainActivity extends AppCompatActivity {

          @Override
          protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.activity_main);

            if (isDeviceRooted()) {
              // Handle rooted device, e.g. by closing the app or notifying the user.
            }

            // Other code...
          }

          private boolean isDeviceRooted() {
            return new(
              File("/system/app/Superuser.apk").exists() ||
              new File("/system/xbin/su").exists());
          }
        }
      description: >
        The secure example checks whether the device is rooted during the
        creation of the main activity. If the device is rooted, the application
        can then decide how to proceed, such as closing the application or
        notifying the user.
- title: Upgrading to Secure TLS Protocol Versions
  need: To protect sensitive information in transit between the client and server.
  vulnerability_id: "016"
  context:
    - Java applications using SSL/TLS for secure communication.
  solution:
    language: java
    insecure_code_example:
      text: |
        SSLContext context = SSLContext.getInstance("TLSv1");
        context.init(null, null, null);
        SSLSocketFactory sf = context.getSocketFactory();
        SSLSocket sslSocket = (SSLSocket) sf.createSocket("hostname", 443);
      description: >
        The above code creates an SSLSocket using the insecure TLSv1 protocol.
    steps:
      - Replace the insecure TLS protocol version (e.g., "TLSv1") with a secure one (e.g., "TLSv1.2" or "TLSv1.3") in the `SSLContext.getInstance` call.
      - Verify that the server also supports the secure protocol version. This might involve server configuration.
    secure_code_example:
      text: |
        SSLContext context = SSLContext.getInstance("TLSv1.3");
        context.init(null, null, null);
        SSLSocketFactory sf = context.getSocketFactory();
        SSLSocket sslSocket = (SSLSocket) sf.createSocket("hostname", 443);
      description: >
        The above code creates an SSLSocket using the secure TLSv1.3 protocol.
        The server must also be configured to accept this protocol.
- title: Insecure Random Number Generation
  need: To ensure the randomness and unpredictability of generated numbers.
  vulnerability_id: "277"
  context:
    - Java applications using the Random class for generating random numbers.
  solution:
    language: java
    insecure_code_example:
      text: |
        import java.util.Random;

        public class Main {
          public static void main(String[] args) {
            Random random = new Random();
            int num = random.nextInt();
            System.out.println("Random number: " + num);
          }
        }
      description: >
        The above code uses the java.util.Random class for generating a random
        number. The `Random` class in Java utilizes a linear congruential generator
        which is not suitable for high-quality randomness.
    steps:
      - Use `java.security.SecureRandom` instead of java.util.Random for generating secure random numbers.
      - SecureRandom generates a cryptographically strong random number.
    secure_code_example:
      text: |
        import java.security.SecureRandom;

        public class Main {
          public static void main(String[] args) {
            SecureRandom secureRandom = new SecureRandom();
            int num = secureRandom.nextInt();
            System.out.println("Secure random number: " + num);
          }
        }
      description: >
        The above code uses the `java.security.SecureRandom` class for
        generating a secure random number. This class provides a
        cryptographically strong random number generator.
- title: Insecure or unset HTTP headers - X-Content-Type-Options
  need: To prevent MIME sniffing attacks by ensuring the server sends the correct MIME type in the response headers.
  context:
    - The solution is applicable for Java version 8 or above.
    - This solution applies to Web MPA, Web SPA, API REST type of applications.
    - The solution is valid when using the javax.servlet and javax.servlet.http.HttpServletResponse packages in a Java web server environment.
  vulnerability_id: "132"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.*;
        import javax.servlet.http.*;

        public class InsecureServlet extends HttpServlet {
          protected void doGet(
            HttpServletRequest req,
            HttpServletResponse resp
          ) throws ServletException, IOException {
            // Vulnerable: Missing the X-Content-Type-Options header
            // Rest of the implementation...
          }
        }
      description: This code is missing the "X-Content-Type-Options" HTTP header in the server response, which could lead to MIME sniffing attacks.
    steps:
      - Add the "X-Content-Type-Options" header to the server response.
      - Set the header value to "nosniff".
    secure_code_example:
      text: |
        import javax.servlet.*;
        import javax.servlet.http.*;

        public class SecureServlet extends HttpServlet {
          protected void doGet(
            HttpServletRequest req,
            HttpServletResponse resp
          ) throws ServletException, IOException {
            // Secure: Setting the X-Content-Type-Options header with a value of nosniff
            resp.setHeader("X-Content-Type-Options", "nosniff");
            // Rest of the implementation...
          }
        }
      description: This code sets the "X-Content-Type-Options" HTTP header in the server response with a value of "nosniff". This disables content or MIME sniffing, reducing the risk of attacks.
- title: Insecure or unset HTTP headers - X-XSS-Protection
  need: To prevent the chance of exploiting a stored Cross-site Scripting (XSS) vulnerability.
  context:
    - The solution is applicable for Java version 8 or above.
    - This solution applies to Web MPA, Web SPA, API REST type of applications.
    - The solution is valid when using the javax.servlet and javax.servlet.http.HttpServletResponse packages in a Java web server environment.
  vulnerability_id: "135"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.*;
        import javax.servlet.http.*;

        public class InsecureServlet extends HttpServlet {
          protected void doGet(
            HttpServletRequest req,
            HttpServletResponse resp
          ) throws ServletException, IOException {
            // Vulnerable: Using deprecated X-XSS-Protection header
            resp.setHeader("X-XSS-Protection", "1; mode=block");
            // Rest of the implementation...
          }
        }
      description: This code is setting the "X-XSS-Protection" HTTP header in the server response, which is a deprecated method of protecting against XSS attacks and can lead to stored XSS vulnerabilities.
    steps:
      - Remove the deprecated "X-XSS-Protection" HTTP header from the server response.
      - Implement security policies using the Content-Security-Policy (CSP) HTTP header instead.
    secure_code_example:
      text: |
        import javax.servlet.*;
        import javax.servlet.http.*;

        public class SecureServlet extends HttpServlet {
          protected void doGet(
            HttpServletRequest req,
            HttpServletResponse resp
          ) throws ServletException, IOException {
            // Secure: Using Content-Security-Policy header
            resp.setHeader("Content-Security-Policy", "default-src 'self'");
            // Rest of the implementation...
          }
        }
      description: This code sets the "Content-Security-Policy" HTTP header in the server response to "default-src 'self'", which ensures that only scripts from the same source as the web page itself can be run, providing a secure defense against XSS attacks.
- title: Uncontrolled External Site Redirect - Host Header Injection
  need: To prevent attacks via redirecting clients to any destination based on Host header value in the request.
  context:
    - The solution is applicable for Java version 8 or above.
    - This solution applies to Web MPA, Web SPA, API REST type of applications.
    - The solution is valid when using the javax.servlet and javax.servlet.http.HttpServletRequest packages in a Java web server environment.
  vulnerability_id: "023"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.*;
        import javax.servlet.http.*;

        public class InsecureServlet extends HttpServlet {
          protected void doPost(
            HttpServletRequest req,
            HttpServletResponse resp
          ) throws ServletException, IOException {
            String redirectUrl = req.getHeader("Host");
            resp.sendRedirect(redirectUrl);
          }
        }
      description: In this code, the Host header of the incoming request is used directly to redirect the client. This allows an attacker to craft requests that can cause the server to redirect the client to any site.
    steps:
      - Never use the Host header directly from an incoming request without validation.
      - Always validate the Host header against a list of allowed hosts.
      - If the Host header doesn't match any allowed host, default to a safe value.
    secure_code_example:
      text: |
        import javax.servlet.*;
        import javax.servlet.http.*;

        public class SecureServlet extends HttpServlet {
          protected void doPost(
            HttpServletRequest req,
            HttpServletResponse resp
          ) throws ServletException, IOException {
            String hostHeader = req.getHeader("Host");
            String allowedHost = "www.trustedsite.com";

            if (allowedHost.equals(hostHeader)) {
              resp.sendRedirect(hostHeader);
            } else {
              resp.sendRedirect(allowedHost);  // default to a safe value
            }
          }
        }
      description: In this secure code, the Host header is validated against an allowed host. If the Host header doesn't match the allowed host, a safe default value is used for the redirect. This prevents the Host header from being abused for redirection attacks.
- title: Apache Lucene Query Injection
  need: To prevent potential information leakage, account balance viewing, and file overwriting by validating and sanitizing untrusted inputs.
  context:
    - The solution is applicable for Java version 8 or above.
    - This solution applies to Web MPA, Web SPA, API REST type of applications where Apache Lucene queries are being performed.
    - The solution is valid when using Apache Lucene for text searching.
  vulnerability_id: "105"
  solution:
    language: java
    insecure_code_example:
      text: |
        import org.apache.lucene.analysis.standard.StandardAnalyzer;
        import org.apache.lucene.queryparser.classic.QueryParser;
        import org.apache.lucene.search.Query;

        public Query buildQuery(String userProvidedQuery) throws ParseException {
            QueryParser parser = new QueryParser("content", new StandardAnalyzer());
            Query query = parser.parse(userProvidedQuery);
            return query;
        }
      description: This insecure code snippet takes a user-provided string and directly uses it to build a Lucene query. This exposes the application to Lucene Query Injection if an attacker crafts a malicious query.
    steps:
      - Avoid constructing Lucene queries directly from untrusted input.
      - Apply input validation and sanitization to user-provided input.
      - Use parameterized methods or safe APIs that auto-escape special characters.
    secure_code_example:
      text: |
        import org.apache.lucene.analysis.standard.StandardAnalyzer;
        import org.apache.lucene.queryparser.classic.QueryParser;
        import org.apache.lucene.search.Query;

        public Query buildQuery(String userProvidedQuery) throws ParseException {
            String safeUserInput = sanitizeInput(userProvidedQuery);
            QueryParser parser = new QueryParser("content", new StandardAnalyzer());
            Query query = parser.parse(safeUserInput);
            return query;
        }

        public String sanitizeInput(String input) {
            // Implementation of input sanitization
            return sanitizedInput;
        }
      description: In this secure code snippet, the user-provided string is sanitized before it is used to construct a Lucene query, mitigating the risk of Lucene Query Injection.
- title: Insecure or Unset HTTP headers - X-Permitted-Cross-Domain-Policies
  need: To prevent harmful cross-domain requests from Adobe Flash or PDF documents by setting appropriate HTTP headers.
  context:
    - The solution is applicable for Java version 8 or above.
    - This solution applies to Web MPA, Web SPA, API REST type of applications where HTTP headers are set.
    - The solution is valid when using javax.servlet API for processing HTTP requests and responses.
  vulnerability_id: "137"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletResponse;

        public void processRequest(HttpServletRequest req, HttpServletResponse resp) {
            // process the request
        }
      description: This insecure code snippet does not set the X-Permitted-Cross-Domain-Policies HTTP header in the server's responses, potentially allowing harmful cross-domain requests from Adobe Flash or PDF documents.
    steps:
      - Always set the X-Permitted-Cross-Domain-Policies HTTP header in the server's responses.
      - Set the X-Permitted-Cross-Domain-Policies HTTP header to "none" unless Adobe products are required.
    secure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletResponse;

        public void processRequest(HttpServletRequest req, HttpServletResponse resp) {
            resp.setHeader("X-Permitted-Cross-Domain-Policies", "none");
            // process the request
        }
      description: In this secure code snippet, the server sets the X-Permitted-Cross-Domain-Policies HTTP header to "none" in its responses, effectively preventing harmful cross-domain requests from Adobe Flash or PDF documents.
- title: Lack of Data Validation - URL
  need: To prevent unauthorized access to user data by validating user permissions.
  context:
    - The solution is applicable for Java version 8 or above.
    - This solution applies to Web MPA, Web SPA, API REST type of applications that use URL parameters for data access.
    - The solution is valid when using javax.servlet API for processing HTTP requests and responses.
  vulnerability_id: "141"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletResponse;

        public void processRequest(HttpServletRequest req, HttpServletResponse resp) {
            String date = req.getParameter("date");
            // process the request based on the date
        }
      description: This insecure code snippet accepts a date parameter from the URL and processes the request based on it without validating whether the user has the right permissions to access the data.
    steps:
      - Validate the user's permissions before processing their request.
      - Only process the request if the user has the right permissions to access the data.
    secure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletResponse;

        public void processRequest(HttpServletRequest req, HttpServletResponse resp) {
            String date = req.getParameter("date");
            User user = (User) req.getSession().getAttribute("user");
            if (user != null && user.hasPermission("view_data")) {
                // process the request based on the date
            }
        }
      description: In this secure code snippet, the server validates whether the user has the right permissions to view the data before processing their request. This is done by checking if the user is logged in and if they have the "view_data" permission.
- title: Insecure or Unset HTTP Headers - X-Frame Options
  need: To prevent clickjacking attacks by using modern, more secure headers instead of deprecated ones.
  context:
    - The solution is applicable for Java version 8 or above.
    - This solution applies to Web MPA, Web SPA, API REST type of applications that serve HTTP responses.
    - The solution is valid when using javax.servlet API for processing HTTP requests and responses.
  vulnerability_id: "152"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletResponse;

        public void doRequest(HttpServletRequest req, HttpServletResponse resp) {
            // process the request...
            resp.setHeader("X-Frame-Options", "SAMEORIGIN");
        }
      description: This insecure code snippet sets the deprecated "X-Frame-Options" header to protect against clickjacking attacks. However, this protection can be bypassed using several iframe layers.
    steps:
      - Remove the "X-Frame-Options" header from the server responses.
      - Use the "Content-Security-Policy" header and define the "frame-ancestors" policy instead.
    secure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletResponse;

        public void doRequest(HttpServletRequest req, HttpServletResponse resp) {
            // process the request...
            resp.setHeader("Content-Security-Policy", "frame-ancestors 'self'");
        }
      description: This secure code snippet removes the deprecated "X-Frame-Options" header and instead uses the "Content-Security-Policy" header with a "frame-ancestors 'self'" policy. This policy prevents the application from being embedded into an iframe unless it's from the same origin.
- title: Insecure or Unset HTTP Headers - Accept
  need: To prevent misuse of unspecified or unvalidated content types in requests, which could lead to unexpected behaviors.
  context:
    - The solution is applicable for Java version 8 or above.
    - This solution applies to Web MPA, Web SPA, API REST type of applications that receive HTTP requests.
    - The solution is valid when using javax.servlet API for processing HTTP requests.
  vulnerability_id: "153"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletResponse;

        public void doRequest(HttpServletRequest req, HttpServletResponse resp) {
            // process the request...
            String contentType = req.getHeader("Accept");
            // content type is not checked...
        }
      description: In this insecure code snippet, the "Accept" header is read from the request, but no check is performed to validate it. This could lead to the application processing requests with an unexpected or harmful content type.
    steps:
      - Define the allowed content types for the application.
      - Validate the "Accept" header of the requests and compare it with the allowed content types.
      - Deny requests that contain a content type different from the expected ones by the application.
    secure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletResponse;

        public void doRequest(HttpServletRequest req, HttpServletResponse resp) {
            // process the request...
            String contentType = req.getHeader("Accept");

            if (!"application/json".equals(contentType)) {
                // deny request...
                resp.setStatus(HttpServletResponse.SC_BAD_REQUEST);
                return;
            }
            // process the request with the expected content type...
        }
      description: This secure code snippet validates the "Accept" header from the request against the expected content type ("application/json" in this example). If the header doesn't match the expected value, the request is denied, preventing the server from interpreting a request with an incorrect or harmful content type.
- title: Insecure or unset HTTP headers - Content-Type
  need: To ensure correct content interpretation by the client browser and prevent MIME type confusion attacks.
  context:
    - The solution is applicable for Java version 8 or above.
    - This solution applies to any web application such as Web MPA, Web SPA, API REST, API GraphQL etc.
    - The solution is valid when using Java Servlet API.
  vulnerability_id: "329"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.*;
        import javax.servlet.http.*;
        import java.io.*;

        public class MyServlet extends HttpServlet {
            public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                PrintWriter out = response.getWriter();
                out.println("Hello World!");
            }
        }
      description: In this insecure code snippet, the servlet sends a response to the client without setting the Content-Type header. This could lead to incorrect interpretation of the response by the client browser and could be potentially exploited in MIME type confusion attacks.
    steps:
      - Always set the Content-Type header in the server responses.
      - The Content-Type should be set to an appropriate value based on the content that is being sent in the response.
    secure_code_example:
      text: |
        import javax.servlet.*;
        import javax.servlet.http.*;
        import java.io.*;

        public class MyServlet extends HttpServlet {
            public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                response.setContentType("text/html; charset=UTF-8");
                PrintWriter out = response.getWriter();
                out.println("<h1>Hello World!</h1>");
            }
        }
      description: This secure code snippet sets the Content-Type header in the response to "text/html; charset=UTF-8" using the `setContentType` method of the `HttpServletResponse` object. This ensures that the client browser correctly interprets the response as HTML text.
- title: Reflected Cross-Site Scripting (XSS)
  need: Protect the application from script injection attacks that can lead to malicious activities such as data theft, site defacement, and distribution of malware.
  context:
    - JavaScript, Node.js v14 or later
    - Web Applications (Web MPA, Web SPA, API REST)
    - Using Express.js framework for handling HTTP requests
  vulnerability_id: "008"
  solution:
    language: javascript
    insecure_code_example:
      text: |
        const express = require('express');
        const app = express();

        app.get('/greet', (req, res) => {
          const name = req.query.name;
          res.send(`<html><body>Hello, ${name}</body></html>`);
        });

        app.listen(3000, () => console.log('Server running on port 3000'));
      description: This code is vulnerable because it directly includes user-provided data ('name') in the output without sanitizing it. If a user enters a string that includes HTML or JavaScript code (for example, '<script>...some malicious code...</script>'), the server will include this in the response and a client's browser will execute it when rendering the page.
    steps:
      - Use a reliable library to sanitize user-provided input. One option is the 'xss' library in Node.js, which provides a highly configurable way to sanitize input and prevent XSS attacks.
      - Always validate user input on the server side. You could use a library like 'validator' to check if the input string has harmful characters.
    secure_code_example:
      text: |
        const express = require('express');
        const xss = require('xss');
        const app = express();

        app.get('/greet', (req, res) => {
          const name = req.query.name;
          const safeName = xss(name);
          res.send(`<html><body>Hello, ${safeName}</body></html>`);
        });

        app.listen(3000, () => console.log('Server running on port 3000'));
      description: This code is safe because it uses the 'xss' library to sanitize the user-provided data ('name') before including it in the output. The 'xss' function removes any potentially harmful characters or strings from the input, preventing the execution of any injected scripts.
- title: Stored Cross-Site Scripting (XSS)
  need: Protect the application from persistent script injection attacks that can lead to unauthorized access, data theft, and distribution of malware.
  context:
    - JavaScript, Node.js v14 or later
    - Web Applications (Web MPA, Web SPA, API REST)
    - Using Express.js framework for handling HTTP requests
    - Using MongoDB for data persistence
  vulnerability_id: "010"
  solution:
    language: javascript
    insecure_code_example:
      text: |
        const express = require('express');
        const app = express();
        const bodyParser = require('body-parser');
        const db = require('mongodb');

        app.use(bodyParser.json());

        app.post('/comments', async (req, res) => {
          const comment = req.body.comment;
          await db.collection('comments').insertOne({ text: comment });
          res.send('Comment added');
        });

        app.listen(3000, () => console.log('Server running on port 3000'));
      description: This code is vulnerable because it directly includes user-provided data ('comment') in the stored data without sanitizing it. If a user enters a string that includes HTML or JavaScript code (for example, '<script>...some malicious code...</script>'), the server will store this input and display it to other users, leading to persistent XSS.
    steps:
      - Use a reliable library to sanitize user-provided input. One option is the 'xss' library in Node.js, which provides a highly configurable way to sanitize input and prevent XSS attacks.
      - Always validate user input on the server side. You could use a library like 'validator' to check if the input string has harmful characters.
    secure_code_example:
      text: |
        const express = require('express');
        const xss = require('xss');
        const app = express();
        const bodyParser = require('body-parser');
        const db = require('mongodb');

        app.use(bodyParser.json());

        app.post('/comments', async (req, res) => {
          const comment = req.body.comment;
          const safeComment = xss(comment);
          await db.collection('comments').insertOne({ text: safeComment });
          res.send('Comment added');
        });

        app.listen(3000, () => console.log('Server running on port 3000'));
      description: This code is safe because it uses the 'xss' library to sanitize the user-provided data ('comment') before storing it in the database. The 'xss' function removes any potentially harmful characters or strings from the input, preventing the execution of any injected scripts when this stored data is displayed to other users.
- title: Uncontrolled External Site Redirect - Host Header Injection
  need: Protect the application from attacks that lead to unauthorized access and information disclosure via manipulation of the 'Host' header in HTTP requests.
  context:
    - JavaScript, Node.js v14 or later
    - Web Applications (Web MPA, Web SPA, API REST)
    - Using Express.js framework
  vulnerability_id: "023"
  solution:
    language: javascript
    insecure_code_example:
      text: |
        const express = require('express');
        const app = express();

        app.get('/redirect', (req, res) => {
          const { url } = req.query;
          res.redirect(url);
        });

        app.listen(3000, () => console.log('Server running on port 3000'));
      description: The code is vulnerable because it accepts any URL from the 'url' query parameter and uses it in a 'redirect' function without validation. An attacker can inject any URL of their choice, leading to a Host Header Injection vulnerability. This can be used to perform phishing attacks, steal sensitive information, or exploit other vulnerabilities.
    steps:
      - Validate the URL before redirecting to it. Ensure that it belongs to a trusted domain or a known path in your application.
      - Consider setting a strict 'Content-Security-Policy' header that limits the number of domains your application can connect to.
    secure_code_example:
      text: |
        const express = require('express');
        const url = require('url');
        const app = express();

        app.get('/redirect', (req, res) => {
          const targetURL = req.query.url;
          const targetHostname = url.parse(targetURL).hostname;

          // Only allow redirection to trusted domains
          if (targetHostname !== 'www.mytrusteddomain.com') {
            return res.status(400).send('Invalid URL');
          }

          res.redirect(targetURL);
        });

        app.listen(3000, () => console.log('Server running on port 3000'));
      description: The code is secure because it validates the 'url' query parameter before redirecting. It ensures that the hostname of the URL is a trusted domain ('www.mytrusteddomain.com' in this example). This prevents an attacker from redirecting to arbitrary domains.
- title: Stored Cross-Site Scripting (XSS) Vulnerability
  need: To prevent attackers from persistently injecting malicious JavaScript code into application fields.
  context:
    - Java 8 and later versions
    - Web MPA, Web SPA
    - Servlet-based web applications using javax.servlet package
  vulnerability_id: "010"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.*;
        import javax.servlet.http.*;

        public class VulnerableServlet extends HttpServlet {
          public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
              String userComment = request.getParameter("comment");

              // The comment is stored in the database without any sanitization
              // Then it is displayed to all users in the application
          }
        }
      description: This servlet gets a user comment from the request and stores it in the database. Later, this comment is displayed to all users. Since the comment is not sanitized before being stored, an attacker could submit a comment containing malicious JavaScript code, which would then be executed by any user viewing the comment.
    steps:
      - Sanitize user input before storing it in the database. This can be done by removing or escaping any HTML or JavaScript code in the input.
      - Use HTTP response headers to disable inline JavaScript.
    secure_code_example:
      text: |
        import javax.servlet.*;
        import javax.servlet.http.*;
        import org.owasp.encoder.Encode;
        public class SecureServlet extends HttpServlet {
          public void doPost(HttpServletRequest request,
              HttpServletResponse response) throws ServletException,
            IOException {
              String userComment = request.getParameter("comment");
              // Sanitize user comment
              String sanitizedComment = Encode.forHtml(userComment);
              // The sanitized comment is now safe to be stored in the database
            }
        }
      description: In the secure servlet, the user comment is sanitized using the OWASP Java Encoder library before being stored in the database. This ensures that any HTML or JavaScript code in the comment is properly escaped and will not be executed when the comment is displayed.
- title: Asymmetric Denial of Service
  need: To prevent service disruption due to excessive resource consumption
  context:
    - Java (version 8 and above)
    - Web applications (MPA, SPA, API REST, API GraphQL)
    - Using javax.servlet package for request handling
  vulnerability_id: "002"
  solution:
    language: java
    insecure_code_example:
      text: |
        public void doGet(HttpServletRequest request,
          HttpServletResponse response) throws ServletException, IOException {
          String keyword = request.getParameter("keyword");
          // Search for keyword
          List < String > results = search(keyword);
          // Return results
          response.getWriter().write(results.toString());
        }
      description: The vulnerable code accepts a keyword from the user and performs a search based on this keyword. However, there is no limit to the time or resources this search can consume. This allows an attacker to cause a denial of service by making a request that results in a very time-consuming search.
    steps:
      - Implement a time limit for the search operation to prevent it from taking too long.
      - Catch and handle any exceptions that could be thrown by the search operation to prevent it from crashing the application.
    secure_code_example:
      text: |
        public void doGet(HttpServletRequest request,
          HttpServletResponse response) throws ServletException, IOException {
          String keyword = request.getParameter("keyword");
          // Search for keyword with time limit
          List < String > results;
          try {
            results = searchWithTimeLimit(keyword, 5000); // 5 seconds limit
          } catch (TimeoutException e) {
            response.getWriter().write(
              "Search timed out. Please try again with a more specific keyword."
              );
            return;
          }
          // Return results
          response.getWriter().write(results.toString());
        }
        private List < String > searchWithTimeLimit(String keyword,
          long timeLimit) throws TimeoutException {
          // Implementation of this method depends on the specific search technology being used
          return new ArrayList < > ();
        }
      description: The secure code implements a time limit for the search operation to prevent it from taking too long. If the search operation does not complete within the time limit, a TimeoutException is thrown and an appropriate response is returned to the user.
- title: Symmetric Denial of Service
  need: To prevent service disruption due to excessive resource consumption
  context:
    - Java (version 8 and above)
    - Web applications (MPA, SPA, API REST, API GraphQL)
    - Using javax.servlet package for request handling
  vulnerability_id: "003"
  solution:
    language: java
    insecure_code_example:
      text: |
        public void doGet(HttpServletRequest request,
          HttpServletResponse response) throws ServletException, IOException {
          String keyword = request.getParameter("keyword");
          // Search for keyword
          List < String > results = search(keyword);
          // Return results
          response.getWriter().write(results.toString());
        }
      description: The vulnerable code accepts a keyword from the user and performs a search based on this keyword. However, there is no limit to the time or resources this search can consume. This allows an attacker to cause a denial of service by repeatedly making requests that result in very time-consuming searches.
    steps:
      - Implement a rate limiting mechanism that limits the number of requests a user can make in a certain period of time.
      - Implement a time limit for the search operation to prevent it from taking too long.
      - Catch and handle any exceptions that could be thrown by the search operation to prevent it from crashing the application.
    secure_code_example:
      text: |
        private RateLimiter rateLimiter = new RateLimiter();
        public void doGet(HttpServletRequest request,
          HttpServletResponse response) throws ServletException, IOException {
          String ip = request.getRemoteAddr();
          // Check rate limit
          if (!rateLimiter.isAllowed(ip)) {
            response.setStatus(HttpServletResponse.SC_TOO_MANY_REQUESTS);
            return;
          }
          String keyword = request.getParameter("keyword");
          // Search for keyword with time limit
          List < String > results;
          try {
            results = searchWithTimeLimit(keyword, 5000); // 5 seconds limit
          } catch (TimeoutException e) {
            response.getWriter().write(
              "Search timed out. Please try again with a more specific keyword."
              );
            return;
          }
          // Return results
          response.getWriter().write(results.toString());
        }
        private class RateLimiter {
          private final long TIME_WINDOW = 60 *
          1000; // 1 minute in milliseconds
          private final int MAX_REQUESTS = 100;
          private Map < String, LinkedList < Long >> requestTimes =
            new HashMap < > ();
          public synchronized boolean isAllowed(String ip) {
            LinkedList < Long > times = requestTimes.getOrDefault(ip,
              new LinkedList < > ());
            // Remove timestamps that are older than the time window
            while (!times.isEmpty() && times.getFirst() < System
              .currentTimeMillis() - TIME_WINDOW) {
              times.removeFirst();
            }
            // Check if the number of requests in the time window exceeds the limit
            if (times.size() >= MAX_REQUESTS) {
              return false;
            }
            // Add timestamp of the new request
            times.addLast(System.currentTimeMillis());
            requestTimes.put(ip, times);
            return true;
          }
        }
        private List < String > searchWithTimeLimit(String keyword,
          long timeLimit) throws TimeoutException {
          // Implementation of this method depends on the specific search technology being used
          return new ArrayList < > ();
        }
      description: The secure code uses a rate limiter to control the frequency of the interactions. It limits the number of requests a user can make in a certain period of time based on the user's IP address. This prevents an attacker from flooding the server with requests. Additionally, a time limit is implemented for the search operation to prevent it from taking too long. If the search operation does not complete within the time limit, a TimeoutException is thrown and an appropriate response is returned to the user.
- title: Cross-Site Request Forgery
  need: To prevent unwanted actions performed on behalf of authenticated users
  context:
    - Java (version 8 and above)
    - Web applications (MPA, SPA)
    - Using javax.servlet package for request handling
  vulnerability_id: "007"
  solution:
    language: java
    insecure_code_example:
      text: |
        public void doPost(HttpServletRequest request,
          HttpServletResponse response) throws ServletException, IOException {
          String userAction = request.getParameter("action");
          // Perform user action
          performAction(userAction);
        }
      description: The vulnerable code accepts an action from the user and performs it. However, there is no verification that the request was made by the user intentionally. This allows an attacker to trick a user into performing an action without their consent.
    steps:
      - Include a CSRF token in the session of each user.
      - Include the CSRF token in each form that can perform an action on behalf of the user.
      - Verify the CSRF token when the form is submitted to ensure the request was made intentionally by the user.
    secure_code_example:
      text: |
        public void doGet(HttpServletRequest request,
          HttpServletResponse response) throws ServletException, IOException {
          String csrfToken = generateCsrfToken();
          request.getSession().setAttribute("csrfToken", csrfToken);
          // Include csrfToken in form...
        }
        public void doPost(HttpServletRequest request,
          HttpServletResponse response) throws ServletException, IOException {
          String userAction = request.getParameter("action");
          String csrfToken = request.getParameter("csrfToken");
          // Check CSRF token
          if (csrfToken == null || !csrfToken.equals(request.getSession()
              .getAttribute("csrfToken"))) {
            response.getWriter().write("Invalid CSRF token.");
            return;
          }
          // Perform user action
          performAction(userAction);
        }
        private String generateCsrfToken() {
          // Generate a random CSRF token
          return UUID.randomUUID().toString();
        }
      description: The secure code includes a CSRF token in the session of each user and in each form that can perform an action on behalf of the user. When the form is submitted, it verifies the CSRF token to ensure the request was made intentionally by the user. This prevents an attacker from tricking a user into performing an action without their consent.
- title: Reflected Cross-Site Scripting (XSS)
  need: To prevent the execution of malicious scripts in the user's browser
  context:
    - Java (version 8 and above)
    - Web applications (MPA, SPA)
    - Using javax.servlet package for request handling
  vulnerability_id: "008"
  solution:
    language: java
    insecure_code_example:
      text: |
        public void doGet(HttpServletRequest request,
          HttpServletResponse response) throws ServletException, IOException {
          String message = request.getParameter("message");
          // Echo message
          response.getWriter().write("You said: " + message);
        }
      description: The vulnerable code echoes back a message provided by the user without validating or encoding the input. This allows an attacker to inject a script that will be executed in the user's browser when they view the message.
    steps:
      - Always validate and sanitize user input to ensure it doesn't contain any scripts.
      - When echoing user input, use a safe method of encoding the output to ensure any scripts are not executed.
    secure_code_example:
      text: |
        import org.apache.commons.text.StringEscapeUtils;
        public void doGet(HttpServletRequest request,
          HttpServletResponse response) throws ServletException, IOException {
          String message = request.getParameter("message");
          // Validate and sanitize input
          message = StringEscapeUtils.escapeHtml4(message);
          // Echo message
          response.getWriter().write("You said: " + message);
        }
      description: The secure code validates and sanitizes the user input by encoding it as HTML. This prevents any scripts in the input from being executed when the message is echoed back to the user.
- title: Stored Cross-Site Scripting (XSS)
  need: To prevent the persistent execution of malicious scripts in the user's browser
  context:
    - Java (version 8 and above)
    - Web applications (MPA, SPA)
    - Using javax.servlet package for request handling
  vulnerability_id: "010"
  solution:
    language: java
    insecure_code_example:
      text: |
        public void doPost(HttpServletRequest request,
          HttpServletResponse response) throws ServletException, IOException {
          String comment = request.getParameter("comment");
          // Store comment
          storeComment(comment);
        }
      description: The vulnerable code stores a comment provided by the user without validating or encoding the input. This allows an attacker to inject a script that will be stored in the database and then executed in the user's browser when they view the comment.
    steps:
      - Always validate and sanitize user input to ensure it doesn't contain any scripts.
      - When displaying user-generated content, use a safe method of encoding the output to ensure any scripts are not executed.
    secure_code_example:
      text: |
        import org.apache.commons.text.StringEscapeUtils;
        public void doPost(HttpServletRequest request,
          HttpServletResponse response) throws ServletException, IOException {
          String comment = request.getParameter("comment");
          // Validate and sanitize input
          comment = StringEscapeUtils.escapeHtml4(comment);
          // Store comment
          storeComment(comment);
        }
      description: The secure code validates and sanitizes the user input by encoding it as HTML. This prevents any scripts in the input from being executed when the comment is displayed to the user.
- title: XPath Injection
  need: To prevent unauthorized access to data stored in XML documents
  context:
    - Java (version 8 and above)
    - Web applications (MPA, SPA)
    - Using javax.servlet package for request handling
    - Using XPath for querying XML data
  vulnerability_id: "021"
  solution:
    language: java
    insecure_code_example:
      text: |
        public void doPost(HttpServletRequest request,
          HttpServletResponse response) throws ServletException, IOException {
          String username = request.getParameter("username");
          // Query user data
          String query = "//users/user[username/text()='" + username + "']";
          NodeList nodes = executeXPath(query);
          // Process user data...
        }
      description: The vulnerable code generates an XPath query including the user-provided username without validating or encoding the input. This allows an attacker to inject XPath expressions that can modify the query to access unauthorized data.
    steps:
      - Always validate and sanitize user input to ensure it doesn't contain any XPath expressions.
      - Use parameterized queries or XPath APIs that support parameterized inputs to prevent injection.
    secure_code_example:
      text: |
        import javax.xml.xpath.*;
        public void doPost(HttpServletRequest request,
          HttpServletResponse response) throws ServletException, IOException {
          String username = request.getParameter("username");
          // Validate and sanitize input
          username = StringEscapeUtils.escapeXml10(username);
          // Query user data using parameterized XPath
          XPathFactory factory = XPathFactory.newInstance();
          XPath xpath = factory.newXPath();
          XPathExpression expr = xpath.compile(
            "//users/user[username/text()=$username]");
          NodeList nodes = (NodeList) expr.evaluate(new Object() {
            public String getUsername() {
              return username;
            }
          }, XPathConstants.NODESET);
          // Process user data...
        }
      description: The secure code validates and sanitizes the user input by encoding it as XML. It then uses a parameterized XPath query to prevent injection of XPath expressions.
- title: Uncontrolled External Site Redirect - Host Header Injection
  need: To prevent redirection to arbitrary external sites
  context:
    - Java (version 8 and above)
    - Web applications (MPA, SPA)
    - Using javax.servlet package for request handling
  vulnerability_id: "023"
  solution:
    language: java
    insecure_code_example:
      text: |
        public void doGet(HttpServletRequest request,
          HttpServletResponse response) throws ServletException, IOException {
          String redirectUrl = request.getHeader("Host");
          // Redirect to the specified URL
          response.sendRedirect(redirectUrl);
        }
      description: The vulnerable code reads the "Host" header from the request and redirects the response to this URL. An attacker can modify the "Host" header to redirect the response to an arbitrary external site.
    steps:
      - Do not rely on the "Host" header for determining the redirect destination.
      - Use a whitelist of allowed redirect destinations and reject any request that does not match the whitelist.
    secure_code_example:
      text: |
        public void doGet(HttpServletRequest request,
          HttpServletResponse response) throws ServletException, IOException {
          String redirectUrl = request.getHeader("Host");
          // Validate the redirect URL
          if (!isRedirectUrlValid(redirectUrl)) {
            response.getWriter().write("Invalid redirect URL.");
            return;
          }
          // Redirect to the specified URL
          response.sendRedirect(redirectUrl);
        }
        private boolean isRedirectUrlValid(String redirectUrl) {
          // Check if the redirect URL is in the whitelist
          List < String > whitelist = Arrays.asList("www.example.com",
            "www.example.org");
          return whitelist.contains(redirectUrl);
        }
      description: The secure code validates the redirect URL against a whitelist of allowed destinations. This prevents an attacker from redirecting the response to an arbitrary external site.
- title: Inadequate File Size Control
  need: To prevent server resource exhaustion and potential denial of service
  context:
    - Java (version 8 and above)
    - Web applications (MPA, SPA)
    - Using javax.servlet and javax.servlet.http packages for request handling
  vulnerability_id: "029"
  solution:
    language: java
    insecure_code_example:
      text: |
        public void doPost(HttpServletRequest request,
          HttpServletResponse response) throws ServletException, IOException {
          Part filePart = request.getPart("file");
          InputStream fileContent = filePart.getInputStream();
          // Save file...
        }
      description: The vulnerable code accepts a file upload without checking the size of the file. This allows an attacker to upload large files that could consume server resources and storage.
    steps:
      - Check the size of the file before processing it.
      - Limit the maximum file size that can be uploaded.
    secure_code_example:
      text: |
        public void doPost(HttpServletRequest request,
          HttpServletResponse response) throws ServletException, IOException {
          Part filePart = request.getPart("file");
          // Check file size
          if (filePart.getSize() > MAX_FILE_SIZE) {
            response.getWriter().write("File too large.");
            return;
          }
          InputStream fileContent = filePart.getInputStream();
          // Save file...
        }
        private static final long MAX_FILE_SIZE = 1024 * 1024; // 1 MB
      description: The secure code checks the size of the uploaded file before processing it. If the file is larger than the maximum allowed size, it rejects the upload. This prevents an attacker from uploading large files that could consume server resources and storage.
- title: Spoofing
  need: To prevent users from impersonating the system or other users
  context:
    - Java (version 8 and above)
    - Web applications (MPA, SPA)
    - Using javax.servlet and javax.servlet.http packages for request handling
  vulnerability_id: "032"
  solution:
    language: java
    insecure_code_example:
      text: |
        public void doPost(HttpServletRequest request,
          HttpServletResponse response) throws ServletException, IOException {
          String message = request.getParameter("message");
          String username = request.getParameter("username");
          // Post message as the specified user
          postMessage(username, message);
        }
      description: The vulnerable code accepts a username and message from the user and posts the message as the specified user. This allows an attacker to post messages that appear to come from another user or the system.
    steps:
      - Do not trust user input for the username or system messages.
      - Use the authenticated user's username when posting messages.
    secure_code_example:
      text: |
        public void doPost(HttpServletRequest request,
          HttpServletResponse response) throws ServletException, IOException {
          String message = request.getParameter("message");
          // Get the authenticated user's username
          String username = getAuthenticatedUsername(request);
          // Post message as the authenticated user
          postMessage(username, message);
        }
        private String getAuthenticatedUsername(HttpServletRequest request) {
          // Retrieve user data from the session
          HttpSession session = request.getSession();
          User user = (User) session.getAttribute("authenticatedUser");
          // Return the username of the authenticated user
          return user.getUsername();
        }
        private void postMessage(String username, String message) {
          // Post message as the specified user...
        }
      description: The secure code uses the authenticated user's username when posting messages. It retrieves the username from the user's session, ensuring that the message is posted under the name of the authenticated user. This prevents an attacker from posting messages that appear to come from another user or the system.
- title: Password Change Without Identity Check
  need: To ensure that only the legitimate user can change their own password
  context:
    - Java (version 8 and above)
    - Web applications (MPA, SPA)
    - Using javax.servlet and javax.servlet.http packages for request handling
  vulnerability_id: "033"
  solution:
    language: java
    insecure_code_example:
      text: |
        public void doPost(
          HttpServletRequest request,
          HttpServletResponse response
        ) throws ServletException, IOException {
          String newPassword = request.getParameter("newPassword");

          // Get the authenticated user's username
          String username = getAuthenticatedUsername(request);

          // Change the user's password
          changePassword(username, newPassword);
        }
      description: The vulnerable code allows a user to change their password without providing the current password or any other form of identity verification. This allows an attacker who has compromised the user's session to change the user's password.
    steps:
      - Require the user to provide their current password when changing their password.
      - Verify the current password before changing it.
    secure_code_example:
      text: |
        public void doPost(
          HttpServletRequest request,
          HttpServletResponse response
        ) throws ServletException, IOException {
          String currentPassword = request.getParameter("currentPassword");
          String newPassword = request.getParameter("newPassword");

          // Get the authenticated user's username
          String username = getAuthenticatedUsername(request);

          // Verify the current password
          if(verifyPassword(username, currentPassword)){
            // Change the user's password
            changePassword(username, newPassword);
          } else {
            response.getWriter().write("Current password is incorrect.");
          }
        }

        private boolean verifyPassword(String username, String currentPassword){
          // Verify the current password...
        }
      description: The secure code requires the user to provide their current password when changing their password. It verifies the current password before changing it. This prevents an attacker who has compromised the user's session from changing the user's password without knowing the current password.
- title: Insecure or Unset HTTP Headers - Content-Security-Policy
  need: To prevent potential attacks from malicious sources by enforcing secure content policies
  context:
    - Java (version 8 and above)
    - Web applications (MPA, SPA)
    - Using javax.servlet and javax.servlet.http packages for request handling
  vulnerability_id: "043"
  solution:
    language: java
    insecure_code_example:
      text: |
        protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
          response.setContentType("text/html;charset=UTF-8");
          // The application does not set the Content-Security-Policy header
        }
      description: The vulnerable code does not set the Content-Security-Policy header in the server responses. This allows for potential attacks from malicious sources.
    steps:
      - Add the Content-Security-Policy header to the server responses.
      - Configure the Content-Security-Policy header to only allow scripts, styles, and other resources from trusted sources.
    secure_code_example:
      text: |
        protected void doGet(
          HttpServletRequest request,
          HttpServletResponse response
        ) throws ServletException, IOException {
          response.setContentType("text/html;charset=UTF-8");

          // Add the Content-Security-Policy header
          response.setHeader("Content-Security-Policy", "script-src 'self';");
        }
      description: The secure code sets the Content-Security-Policy header in the server responses. It configures the header to only allow scripts from the same origin ('self'). This prevents potential attacks from malicious sources.
- title: Insecure HTTP Methods Enabled
  need: To prevent potential security risks associated with the use of insecure HTTP methods
  context:
    - Java (version 8 and above)
    - Web applications (MPA, SPA)
    - Using javax.servlet and javax.servlet.http packages for request handling
  vulnerability_id: "044"
  solution:
    language: java
    insecure_code_example:
      text: |
        @Override
        protected void doDelete(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
          // Delete operation is enabled
        }

        @Override
        protected void doPut(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
          // Put operation is enabled
        }
      description: The insecure code enables DELETE and PUT HTTP methods which can be exploited by an attacker to delete or modify data.
    steps:
      - Disable or limit the use of insecure HTTP methods such as DELETE and PUT.
      - Implement access controls to ensure only authorized users can perform certain operations.
    secure_code_example:
      text: |
        @Override
        protected void doDelete(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
          throw new ServletException("Delete operation is not allowed.");
        }

        @Override
        protected void doPut(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
          throw new ServletException("Put operation is not allowed.");
        }
      description: The secure code throws an exception when DELETE and PUT HTTP methods are used, effectively disabling these methods and preventing potential security risks.
- title: HTML Code Injection
  need: To prevent potential security risks associated with the injection of HTML code into the application fields
  context:
    - Java (version 8 and above)
    - Web applications (MPA, SPA)
    - Using javax.servlet and javax.servlet.http packages for request handling
  vulnerability_id: "045"
  solution:
    language: java
    insecure_code_example:
      text: |
        @Override
        protected void doPost(
          HttpServletRequest req,
          HttpServletResponse resp
        ) throws ServletException, IOException {
            String userComment = req.getParameter("comment");
            // directly using user input in response
            resp.getWriter().write("<html><body>User comment: " + userComment + "</body></html>");
        }
      description: This insecure code does not sanitize user input before using it to generate HTML content, which can lead to HTML code injection.
    steps:
      - Sanitize user input before using it to generate HTML content.
      - Use functions that encode special characters in the user input to their HTML equivalent.
    secure_code_example:
      text: |
        @Override
        protected void doPost(
          HttpServletRequest req,
          HttpServletResponse resp
        ) throws ServletException, IOException {
          String userComment = req.getParameter("comment");
          // HTML encoding user input
          String safeUserComment = StringEscapeUtils.escapeHtml4(userComment);
          resp.getWriter().write("<html><body>User comment: " +
            safeUserComment + "</body></html>");
        }
      description: The secure code example escapes special HTML characters in the user input before using it to generate HTML content. This prevents an attacker from injecting HTML code.
- title: Asymmetric Denial of Service - Content Length
  need: Prevent the server from being overwhelmed by large requests or slow loris attacks
  context:
    - Java (version 8 and above)
    - Web applications (MPA, SPA)
    - Using javax.servlet and javax.servlet.http packages for request handling
  vulnerability_id: "057"
  solution:
    language: java
    insecure_code_example:
      text: |
        @Override
        protected void doPost(HttpServletRequest req,
          HttpServletResponse resp) throws ServletException, IOException {
            // Insecure code does not check the size of the request
            String data = req.getReader().lines().collect(Collectors.joining(
              System.lineSeparator()));
            process(data);
          }
      description: This insecure code does not check the size of the request, allowing an attacker to send a large request that could overwhelm the server.
    steps:
      - Check the size of the request before processing it.
      - If the request is too large, respond with an error and stop processing.
    secure_code_example:
      text: |
        @Override
        protected void doPost(HttpServletRequest req,
          HttpServletResponse resp) throws ServletException, IOException {
            int size = req.getContentLength();
            if (size > MAX_SIZE) {
              resp.setStatus(HttpServletResponse.SC_REQUEST_ENTITY_TOO_LARGE);
              return;
            }
            String data = req.getReader().lines().collect(Collectors.joining(
              System.lineSeparator()));
            process(data);
          }
      description: The secure code example checks the size of the request before processing it. If the request is too large, it responds with a 413 error (Request Entity Too Large) and stops processing.
- title: Remote File Inclusion
  need: Prevent the server from loading and executing malicious files from remote locations
  context:
    - Java (version 8 and above)
    - Web applications (MPA, SPA)
    - Using javax.servlet and javax.servlet.http packages for request handling
  vulnerability_id: "061"
  solution:
    language: java
    insecure_code_example:
      text: |
        @Override
        protected void doGet(
          HttpServletRequest req,
          HttpServletResponse resp
        ) throws ServletException, IOException {
            String className = req.getParameter("class");
            try {
                Class<?> clazz = Class.forName(className);
                Object instance = clazz.newInstance();
                Method method = clazz.getMethod("execute");
                method.invoke(instance);
            } catch (Exception e) {
                throw new ServletException(e);
            }
        }
      description: This insecure code loads a Java class specified by a request parameter and executes a method on it. An attacker could potentially load and execute a malicious class.
    steps:
      - Do not load classes based on user input.
      - If you need to execute code based on user input, use a safe mechanism such as a command pattern.
    secure_code_example:
      text: |
        private static final Map<String, Command> COMMANDS = Map.of(
            "command1", new Command1(),
            "command2", new Command2()
        );

        @Override
        protected void doGet(
          HttpServletRequest req,
          HttpServletResponse resp
        ) throws ServletException, IOException {
            String commandName = req.getParameter("command");
            Command command = COMMANDS.get(commandName);
            if (command != null) {
                command.execute();
            } else {
                resp.setStatus(HttpServletResponse.SC_BAD_REQUEST);
            }
        }
      description: The secure code example uses a command pattern. Instead of loading a class based on user input, it executes a predefined command based on user input.
- title: Concurrent Sessions
  need: Ensure user actions are traceable and non-repudiable by restricting the number of concurrent sessions
  context:
    - Java (version 8 and above)
    - Web applications (MPA, SPA)
    - Using javax.servlet and javax.servlet.http packages for request handling
  vulnerability_id: "062"
  solution:
    language: java
    insecure_code_example:
      text: |
        @Override
        protected void doPost(
          HttpServletRequest req,
          HttpServletResponse resp
        ) throws ServletException, IOException {
            String username = req.getParameter("username");
            String password = req.getParameter("password");

            if (isValidUser(username, password)) {
                req.getSession(true); // Always creates a new session if one doesn't exist
            }
        }

        private boolean isValidUser(String username, String password) {
            // Authentication logic goes here
            return true;
        }
      description: This insecure code always creates a new session for each valid login attempt. This allows a single user to have multiple active sessions.
    steps:
      - Do not automatically create a new session for each login attempt.
      - Check if a session already exists for the user and invalidate it before creating a new one.
    secure_code_example:
      text: |
        @Override
        protected void doPost(
          HttpServletRequest req,
          HttpServletResponse resp
        ) throws ServletException, IOException {
            String username = req.getParameter("username");
            String password = req.getParameter("password");

            if (isValidUser(username, password)) {
                HttpSession existingSession = req.getSession(false);
                if (existingSession != null) {
                    existingSession.invalidate();
                }
                req.getSession(true); // Now creates a new session
            }
        }

        private boolean isValidUser(String username, String password) {
            // Authentication logic goes here
            return true;
        }
      description: The secure code example checks if a session already exists for the user. If so, it invalidates the session before creating a new one. This ensures that a user can only have one active session.
- title: Path Traversal
  need: Prevent unauthorized access to files by ensuring paths are properly validated
  context:
    - Java (version 8 and above)
    - Web applications (MPA, SPA)
    - Using javax.servlet and javax.servlet.http packages for request handling
  vulnerability_id: "063"
  solution:
    language: java
    insecure_code_example:
      text: |
        @Override
        protected void doGet(
          HttpServletRequest req,
          HttpServletResponse resp
        ) throws ServletException, IOException {
            String filename = req.getParameter("filename");
            File file = new File("user_directory/" + filename);
            // Rest of the code that uses the file
        }
      description: In this insecure code, the filename is directly taken from the user input and is concatenated to the 'user_directory/'. An attacker can provide a filename like '../../etc/passwd' to access sensitive files.
    steps:
      - Do not directly use user input to access files or directories.
      - Use a whitelist of allowed paths or validate the path to ensure it does not traverse outside the intended directory.
    secure_code_example:
      text: |
        @Override
        protected void doGet(
          HttpServletRequest req,
          HttpServletResponse resp
        ) throws ServletException, IOException {
          String filename = req.getParameter("filename");
          File file = new File("user_directory/" + filename);
          // Ensure the file is within the intended directory
          if (file.getCanonicalPath().startsWith(new File("user_directory/")
              .getCanonicalPath())) {
            // Rest of the code that uses the file
          } else {
            throw new SecurityException(
              "Attempted to access file outside of the allowed directory");
          }
        }
      description: The secure code validates that the final path of the file is within the 'user_directory/' before using it. This prevents an attacker from using path traversal to access files outside of the intended directory.
- title: Insecure Session Expiration Time
  need: Ensuring user sessions expire after a certain period of inactivity
  context:
    - Java (version 8 and above)
    - Web applications (MPA, SPA)
    - Using javax.servlet and javax.servlet.http packages for request handling
  vulnerability_id: "068"
  solution:
    language: java
    insecure_code_example:
      text: |
        @Override
        protected void doGet(
          HttpServletRequest req,
          HttpServletResponse resp
          ) throws ServletException, IOException {
            HttpSession session = req.getSession(true);
            // Rest of the code
        }
      description: In this insecure code, a session is created or returned without setting an inactivity timeout. The session can remain active indefinitely if the user does not manually log out.
    steps:
      - Set an inactivity timeout for sessions.
      - The timeout should be as short as is reasonable for your application.
    secure_code_example:
      text: |
        @Override
        protected void doGet(
          HttpServletRequest req,
          HttpServletResponse resp
        ) throws ServletException, IOException {
            HttpSession session = req.getSession(true);
            session.setMaxInactiveInterval(5*60); // Sets a 5 minute inactivity timeout
            // Rest of the code
        }
      description: The secure code sets a maximum inactivity interval of 5 minutes on the session. If the user does not make a request within this time, the session will be invalidated.
- title: Insecure or Unset HTTP Headers - Referrer-Policy
  need: Ensuring that the Referrer-Policy HTTP header is correctly set
  context:
    - Java (version 8 and above)
    - Web applications (MPA, SPA)
    - Using javax.servlet and javax.servlet.http packages for request handling
  vulnerability_id: "071"
  solution:
    language: java
    insecure_code_example:
      text: |
        @Override
        protected void doGet(
          HttpServletRequest req,
          HttpServletResponse resp
        ) throws ServletException, IOException {
            // Rest of the code
        }
      description: In this insecure code, the response is sent without setting the Referrer-Policy HTTP header. This can lead to potential leaks of website domain and path to external services.
    steps:
      - Set the Referrer-Policy HTTP header in the response to either no-referrer, same-origin, strict-origin, or strict-origin-when-cross-origin.
    secure_code_example:
      text: |
        @Override
        protected void doGet(
          HttpServletRequest req,
          HttpServletResponse resp
        ) throws ServletException, IOException {
            resp.setHeader("Referrer-Policy", "no-referrer"); // Sets the Referrer-Policy header to 'no-referrer'
            // Rest of the code
        }
      description: The secure code sets the Referrer-Policy header to 'no-referrer'. This ensures that the browser will not include a referrer URL in the Request headers when the user navigates from your site to another.
- title: Insecure Session Management
  need: Ensuring the expiration of session tokens after user logout
  context:
    - Java (version 8 and above)
    - Web applications (MPA, SPA)
    - Using javax.servlet and javax.servlet.http packages for session handling
  vulnerability_id: "076"
  solution:
    language: java
    insecure_code_example:
      text: |
        protected void doPost(
          HttpServletRequest request,
          HttpServletResponse response
        ) throws ServletException, IOException {
            // Login logic...
            HttpSession session = request.getSession();
            session.setAttribute("user", user);
        }

        protected void doDelete(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            // Logout logic...
        }
      description: In this insecure code example, a user session is created upon successful login, but the session is not invalidated during logout, leading to the possibility of session hijacking.
    steps:
      - Invalidate the user's session upon logging out to ensure the session token can no longer be used.
    secure_code_example:
      text: |
        protected void doPost(
          HttpServletRequest request,
          HttpServletResponse response
        ) throws ServletException, IOException {
            // Login logic...
            HttpSession session = request.getSession();
            session.setAttribute("user", user);
        }

        protected void doDelete(
          HttpServletRequest request,
          HttpServletResponse response
        ) throws ServletException, IOException {
            // Logout logic...
            HttpSession session = request.getSession();
            if (session != null) {
                session.invalidate();
            }
        }
      description: The secure code properly invalidates the session upon user logout, ensuring that the session token cannot be used to make requests after the session has ended.
- title: XML Injection (XXE)
  need: Prevent the execution of untrusted XML that could lead to unauthorized data exposure, denial of service, or remote code execution.
  context:
    - Java (version 8 and above)
    - Web applications (MPA, SPA, API REST)
    - Using javax.xml.parsers package for XML parsing
  vulnerability_id: "083"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.xml.parsers.DocumentBuilder;
        import javax.xml.parsers.DocumentBuilderFactory;

        DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
        DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
        Document doc = dBuilder.parse(someInputXML);
      description: In the insecure code example, the DocumentBuilderFactory instance is not secured against XML External Entity (XXE) attacks. It directly parses XML from an untrusted source.
    steps:
      - Configure the XML parser to disable DTDs (External Entities) completely.
    secure_code_example:
      text: |
        import javax.xml.parsers.DocumentBuilder;
        import javax.xml.parsers.DocumentBuilderFactory;
        DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
        dbFactory.setFeature(
          "http://apache.org/xml/features/disallow-doctype-decl", true);
        dbFactory.setFeature(
          "http://xml.org/sax/features/external-general-entities", false);
        dbFactory.setFeature(
          "http://xml.org/sax/features/external-parameter-entities", false);
        dbFactory.setFeature(
          "http://apache.org/xml/features/nonvalidating/load-external-dtd",
          false);
        DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
        Document doc = dBuilder.parse(someInputXML);
      description: In the secure code example, the DocumentBuilderFactory instance is configured to disable DTDs and external entities, thus mitigating the risk of XXE attacks.
- title: Account Lockout
  need: Prevent users from being locked out of their accounts by malicious attempts.
  context:
    - Java (version 8 and above)
    - Web applications (MPA, SPA, API REST)
    - Using javax.servlet.http package for handling HTTP requests
  vulnerability_id: "087"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletResponse;

        public void doPost(
          HttpServletRequest request,
          HttpServletResponse response
        ) {
          String username = request.getParameter("username");
          String password = request.getParameter("password");

          User user = getUserByUsername(username);
          if (user != null && user.getPassword().equals(password)) {
            // User is authenticated
          } else {
            // Increase failed login attempts
            user.increaseFailedLoginAttempts();

            // Lock account if failed login attempts exceed limit
            if (user.getFailedLoginAttempts() > MAX_FAILED_ATTEMPTS) {
              user.lockAccount();
            }
          }
        }

        private User getUserByUsername(String username) {
          // Placeholder method to retrieve user
          return new User();
        }
      description: In this insecure code example, the application locks an account if the number of failed login attempts exceeds a certain limit. An attacker could repeatedly attempt to login with incorrect passwords and cause a legitimate user's account to be locked.
    steps:
      - Implement a delay after a certain number of failed login attempts instead of locking the account.
    secure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletResponse;

        public void doPost(
          HttpServletRequest request,
          HttpServletResponse response
        ) {
          String username = request.getParameter("username");
          String password = request.getParameter("password");

          User user = getUserByUsername(username);
          if (user != null && user.getPassword().equals(password)) {
            // User is authenticated
          } else {
            // Increase failed login attempts
            user.increaseFailedLoginAttempts();

            // Delay next login attempt if failed login attempts exceed limit
            if (user.getFailedLoginAttempts() > MAX_FAILED_ATTEMPTS) {
              user.delayNextLoginAttempt();
            }
          }
        }

        private User getUserByUsername(String username) {
          // Placeholder method to retrieve user
          return new User();
        }
      description: In the secure code example, the application delays the next login attempt after a certain number of failed attempts, instead of locking the account. This still deters brute force attacks but doesn't allow an attacker to lock a user out of their account.
- title: Trust Boundary Violation
  need: Ensure data integrity by separating trusted and untrusted data
  context:
    - Java (version 8 and above)
    - Web applications (MPA, SPA, API REST)
    - Using javax.servlet.http package for handling HTTP requests
  vulnerability_id: "089"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletResponse;

        public void doPost(
          HttpServletRequest request,
          HttpServletResponse response
        ) {
          String username = request.getParameter("username");
          String password = request.getParameter("password");

          // Mix trusted and untrusted data
          String loginCredentials = "username:" + username + ",password:" + password;

          // Use mixed data for further processing
          // ...
        }
      description: In this insecure code example, the application mixes trusted (hardcoded strings "username:" and "password:") and untrusted data (user input from HTTP request) in the same data structure. This can lead to injection attacks if the untrusted data is not properly sanitized.
    steps:
      - Separate the handling of trusted and untrusted data.
      - Validate or sanitize untrusted data before using it.
    secure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletResponse;
        public void doPost(
          HttpServletRequest request,
          HttpServletResponse response
        ) {
          String username = request.getParameter("username");
          String password = request.getParameter("password");
          // Validate or sanitize untrusted data
          username = validateInput(username);
          password = validateInput(password);
          // Separate handling of trusted and untrusted data
          String loginCredentials = "username:" + username + ",password:" +
            password;
          // Use validated/sanitized data for further processing
          // ...
        }
        private String validateInput(String input) {
          // Placeholder method to validate or sanitize input
          return input;
        }
      description: In the secure code example, the application separates the handling of trusted and untrusted data. It validates or sanitizes the untrusted data (user input from HTTP request) before using it, ensuring that the integrity of the data is maintained.
- title: CSV Injection
  need: Ensure the integrity and safety of exported CSV data
  context:
    - Java (version 8 and above)
    - Web applications (MPA, SPA, API REST)
    - Using javax.servlet.http package for handling HTTP requests
    - Using java.io.Writer for file output
  vulnerability_id: "090"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import java.io.Writer;

        public void exportCSV(
          HttpServletRequest request,
          Writer writer
        ) throws IOException {
          String username = request.getParameter("username");
          String data = request.getParameter("data");

          // Write data to CSV without validation
          writer.write(username + "," + data + "\n");
        }
      description: In this insecure code example, the application writes user input directly to a CSV file without any validation or sanitization. This allows an attacker to inject malicious formulas into the CSV file.
    steps:
      - Validate and sanitize user input before writing to the CSV file.
      - Check for leading characters such as '=', '+', '-', or '@' which can trigger a formula in spreadsheet software.
    secure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import java.io.Writer;
        public void exportCSV(HttpServletRequest request,
          Writer writer) throws IOException {
            String username = sanitizeInput(request.getParameter("username"));
            String data = sanitizeInput(request.getParameter("data"));
            // Write sanitized data to CSV
            writer.write(username + "," + data + "\n");
          }
        private String sanitizeInput(String input) {
          // Sanitize input to prevent CSV injection
          if (input != null && (input.startsWith("=") || input.startsWith(
              "+") || input.startsWith("-") || input.startsWith("@"))) {
            return "'" + input;
          }
          return input;
        }
      description: In the secure code example, the application sanitizes user input before writing it to a CSV file. The sanitizeInput method checks for leading characters that can trigger a formula in spreadsheet software and prepends a single quote (') if such a character is found. This prevents the injected data from being interpreted as a formula.
- title: Log Injection
  need: Ensure the integrity and safety of log data
  context:
    - Java (version 8 and above)
    - Web applications (MPA, SPA, API REST)
    - Using javax.servlet.http package for handling HTTP requests
    - Using java.util.logging package for logging
  vulnerability_id: "091"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import java.util.logging.Logger;

        public class LogExample {
          private static final Logger LOGGER = Logger.getLogger(
            LogExample.class.getName()
          );

          public void handleRequest(HttpServletRequest request) {
              String username = request.getParameter("username");
              LOGGER.info("User login: " + username);
          }
        }
      description: In this insecure code example, the application writes user input directly to a log file without any validation or sanitization. This allows an attacker to inject malicious content into the log file.
    steps:
      - Validate and sanitize user input before writing to the log file.
    secure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import java.util.logging.Logger;

        public class LogExample {
          private static final Logger LOGGER = Logger.getLogger(
            LogExample.class.getName()
          );

          public void handleRequest(HttpServletRequest request) {
              String username = sanitizeInput(
                request.getParameter("username")
              );
              LOGGER.info("User login: " + username);
          }

          private String sanitizeInput(String input) {
              // Replace dangerous characters to prevent log injection
              if (input != null) {
                  return input.replaceAll("\n", "_").replaceAll("\r", "_");
              }
              return input;
          }
        }
      description: In the secure code example, the application sanitizes user input before writing it to a log file. The sanitizeInput method replaces newline and return carriage characters, which could be used for log injection, with safe characters.
- title: Data Uniqueness Not Properly Verified
  need: Ensure uniqueness of data to prevent duplication or reuse
  context:
    - Java (version 8 and above)
    - Web applications (MPA, SPA, API REST)
    - Using javax.servlet.http package for handling HTTP requests
    - Using java.util.Set for collection of unique elements
  vulnerability_id: "095"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;

        public class UniqueDataExample {
          public void handleRequest(HttpServletRequest request) {
              String data = request.getParameter("data");
              // Assume that processNonUniqueData() processes the data without verifying its uniqueness
              processNonUniqueData(data);
          }

          private void processNonUniqueData(String data) {
              // Processing data...
          }
        }
      description: In this insecure code example, the application processes user data without verifying its uniqueness. This allows an attacker to reuse or regenerate information that should be valid for one use only.
    steps:
      - Verify the uniqueness of data before processing it.
    secure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import java.util.HashSet;
        import java.util.Set;

        public class UniqueDataExample {
          private Set<String> uniqueDataSet = new HashSet<>();

          public void handleRequest(HttpServletRequest request) {
              String data = request.getParameter("data");
              if (uniqueDataSet.contains(data)) {
                  // Reject the data because it's not unique
                  return;
              }
              uniqueDataSet.add(data);
              processUniqueData(data);
          }

          private void processUniqueData(String data) {
              // Processing data...
          }
        }
      description: In the secure code example, the application verifies the uniqueness of user data before processing it. A Set data structure is used to store and verify the uniqueness of data.
- title: Insecure Deserialization
  need: Ensure safe deserialization by validating and casting serialized objects
  context:
    - Java (version 8 and above)
    - Web applications (MPA, SPA, API REST)
    - Using javax.servlet.http package for handling HTTP requests
    - Using java.io.ObjectInputStream for deserialization
  vulnerability_id: "096"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import java.io.ObjectInputStream;

        public class InsecureDeserializationExample {
          public void handleRequest(HttpServletRequest request) {
              try {
                  ObjectInputStream objectInputStream =
                    new ObjectInputStream(request.getInputStream());
                  Object deserializedObject = objectInputStream.readObject();
                  processObject(deserializedObject);
              } catch (Exception e) {
                  // Handle exception
              }
          }

          private void processObject(Object object) {
              // Processing object...
          }
        }
      description: In this insecure code example, the application deserializes an object without validating its content or casting it to a specific type. This allows an attacker to control the application execution flow.
    steps:
      - Validate the serialized object before deserialization.
      - Cast the deserialized object to the specific type you expect.
    secure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import java.io.ObjectInputStream;

        public class SecureDeserializationExample {
          public void handleRequest(HttpServletRequest request) {
              try {
                  ObjectInputStream objectInputStream =
                    new ObjectInputStream(request.getInputStream());
                  Object deserializedObject = objectInputStream.readObject();

                  // Validation and casting to a specific type
                  if (!(deserializedObject instanceof ExpectedObjectType)) {
                      // Reject the object because it's not of the expected type
                      return;
                  }

                  ExpectedObjectType expectedObject =
                    (ExpectedObjectType) deserializedObject;
                  processObject(expectedObject);
              } catch (Exception e) {
                  // Handle exception
              }
          }

          private void processObject(ExpectedObjectType object) {
              // Processing object...
          }
        }
      description: In the secure code example, the application validates the deserialized object and casts it to the expected type before processing. This reduces the risk of an attacker controlling the application execution flow.
- title: External Control of File Name or Path
  need: Ensure secure file uploads by restricting and validating file paths
  context:
    - Java (version 8 and above)
    - Web applications (MPA, SPA, API REST)
    - Using javax.servlet.http package for handling HTTP requests
    - Using javax.servlet.http.Part for handling file uploads
  vulnerability_id: "098"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.Part;
        import java.io.File;
        import java.io.IOException;

        public class InsecureFileUploadExample {
          public void handleFileUpload(HttpServletRequest request) {
              try {
                  Part filePart = request.getPart("file");
                  String fileName = filePart.getSubmittedFileName();

                  File file = new File("uploads/" + fileName);
                  filePart.write(file.getAbsolutePath());
              } catch (Exception e) {
                  // Handle exception
              }
          }
        }
      description: In this insecure code example, the application allows the uploaded file's original name to determine the destination path. An attacker can manipulate the file name to overwrite important files within the system.
    steps:
      - Validate the name of the uploaded file.
      - Restrict the file saving path to the destined folder only.
    secure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.Part;
        import java.io.File;
        import java.io.IOException;
        import java.nio.file.Paths;
        public class SecureFileUploadExample {
          public void handleFileUpload(HttpServletRequest request) {
            try {
              Part filePart = request.getPart("file");
              String fileName = Paths.get(filePart.getSubmittedFileName())
                .getFileName().toString(); // Extract file name
              // Validate the file name and restrict path
              if (!isValidFileName(fileName)) {
                // Reject the file
                return;
              }
              File uploads = new File("uploads");
              File file = new File(uploads, fileName);
              filePart.write(file.getAbsolutePath());
            } catch (Exception e) {
              // Handle exception
            }
          }
          private boolean isValidFileName(String fileName) {
            // Check if the filename is not null or empty
            if (fileName == null || fileName.trim().isEmpty()) {
              return false;
            }
            // Check if the filename contains invalid characters like: '\', '/', ':', '*', '?', '<', '>', '|'
            String invalidChars = "\\/:*?\"<>|";
            for (char c: invalidChars.toCharArray()) {
              if (fileName.indexOf(c) >= 0) {
                return false;
              }
            }
            return true;
          }
        }
      description: In the secure code example, the application validates the uploaded file's name and restricts the saving path to the destined folder only. This prevents an attacker from overwriting important system files.
- title: Email Uniqueness Not Properly Verified
  need: Ensure unique user account per email address
  context:
    - Java (version 8 and above)
    - Web applications (MPA, SPA, API REST)
    - Using javax.servlet.http package for handling HTTP requests
    - Using javax.mail.internet.InternetAddress for handling email addresses
  vulnerability_id: "102"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import javax.mail.internet.InternetAddress;

        public class InsecureRegistrationExample {
          public void registerUser(HttpServletRequest request) {
              try {
                  String email = request.getParameter("email");
                  // Assume createUserWithEmail creates a user with the given email
                  createUserWithEmail(email);
              } catch (Exception e) {
                  // Handle exception
              }
          }
        }
      description: In this insecure code example, the application accepts any email address provided by the user during the registration process, including email addresses with the plus character, leading to the creation of multiple accounts for the same inbox.
    steps:
      - Before creating a user, normalize the email address by removing any special characters like '+'.
      - After normalization, check if a user with the given email address already exists.
    secure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import javax.mail.internet.InternetAddress;

        public class SecureRegistrationExample {
          public void registerUser(HttpServletRequest request) {
              try {
                  String email = request.getParameter("email");
                  email = normalizeEmail(email);

                  if (userExists(email)) {
                      // Reject the registration
                      return;
                  }

                  createUserWithEmail(email);
              } catch (Exception e) {
                  // Handle exception
              }
          }

          private String normalizeEmail(String email) throws Exception {
              InternetAddress emailAddr = new InternetAddress(email);
              emailAddr.validate();
              String emailLocalPart = emailAddr.getAddress()
                .split("@")[0].replace("+", "");
              String emailDomainPart = emailAddr.getAddress().split("@")[1];
              return emailLocalPart + "@" + emailDomainPart;
          }

          private boolean userExists(String email) {
              // Check if a user with the given email address already exists
              // This is an example, replace it with actual code for your application
              return false;
          }
        }
      description: In the secure code example, the application first normalizes the email address by removing any '+' character from the local part. Then it checks if a user with the given email address already exists. If a user exists, the registration is rejected.
- title: Apache Lucene Query Injection
  need: Ensure that query execution is secure and prevent unauthorized access or modification of data
  context:
    - Java (version 8 and above)
    - Web applications (MPA, SPA, API REST)
    - Using javax.servlet.http package for handling HTTP requests
    - Using Apache Lucene for search operations
  vulnerability_id: "105"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import org.apache.lucene.search.Query;
        import org.apache.lucene.search.QueryParser;

        public class InsecureSearchExample {
          public void search(HttpServletRequest request) {
              try {
                  String searchQuery = request.getParameter("searchQuery");
                  QueryParser parser =
                    new QueryParser("fieldName", new StandardAnalyzer());
                  Query query = parser.parse(searchQuery);
                  // Assume performSearch executes the given query
                  performSearch(query);
              } catch (Exception e) {
                  // Handle exception
              }
          }
        }
      description: In this insecure code example, the application accepts a search query directly from the user and uses it to create a Lucene query without any validation or sanitization. This allows an attacker to inject malicious queries.
    steps:
      - Validate and sanitize the user input before using it to create a Lucene query.
      - Use a whitelist of allowed characters in the search query.
      - Consider escaping special characters in the search query to prevent them from altering the query structure.
    secure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import org.apache.lucene.search.Query;
        import org.apache.lucene.queryparser.classic.QueryParser;
        import org.apache.lucene.analysis.standard.StandardAnalyzer;

        public class SecureSearchExample {
          public void search(HttpServletRequest request) {
              try {
                  String searchQuery = request.getParameter("searchQuery");
                  searchQuery = sanitizeInput(searchQuery);
                  QueryParser parser = new QueryParser(
                    "fieldName", new StandardAnalyzer()
                  );
                  Query query = parser.parse(searchQuery);
                  performSearch(query);
              } catch (Exception e) {
                  // Handle exception
              }
          }

          private String sanitizeInput(String input) {
              // Replace special characters with escape sequences
              return QueryParser.escape(input);
          }
        }
      description: In the secure code example, the application sanitizes the search query input from the user before using it to create a Lucene query. This is done by using the QueryParser.escape method, which escapes any special characters in the input string that could alter the query structure.
- title: Improper Control of Interaction Frequency
  need: Ensure the system's availability by preventing users from overloading it with requests.
  context:
    - Java (version 8 and above)
    - Web applications (MPA, SPA, API REST)
    - Using javax.servlet.http package for handling HTTP requests
  vulnerability_id: "108"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletResponse;

        public class InsecureController {
          public void handleRequest(
            HttpServletRequest request,
            HttpServletResponse response
          ) {
              // Process request without any rate limiting
              processRequest(request, response);
          }
        }
      description: In this insecure code example, the application processes every request without any rate limiting. This allows an attacker to flood the server with requests, which can lead to a denial of service.
    steps:
      - Implement rate limiting to control the number of requests that a user can make in a certain time period.
      - Consider using a library or framework that provides rate limiting features.
    secure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletResponse;
        import com.google.common.util.concurrent.RateLimiter;

        public class SecureController {
          private final RateLimiter rateLimiter = RateLimiter.create(5.0);  // Allow 5 requests per second

          public void handleRequest(
            HttpServletRequest request,
            HttpServletResponse response
          ) {
              if (rateLimiter.tryAcquire()) {
                  // Process request
                  processRequest(request, response);
              } else {
                  // Too many requests, respond with 429 status code
                  response.setStatus(HttpServletResponse.SC_TOO_MANY_REQUESTS);
              }
          }
        }
      description: In the secure code example, the application uses a RateLimiter from the Guava library to limit the number of requests that a user can make per second. If a user exceeds this limit, the application responds with a 429 status code, indicating that too many requests have been made.
- title: Improper Type Assignation
  need: To prevent type confusion errors and enhance code readability and efficiency.
  context:
    - Java (version 8 and above)
    - Web applications (MPA, SPA, API REST)
    - Using javax.servlet.http package for handling HTTP requests
  vulnerability_id: "113"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletResponse;

        public class InsecureController {
          public void handleRequest(
            HttpServletRequest request,
            HttpServletResponse response
          ) {
              Object item = request.getParameter("item");
              processRequest(item);
          }

          private void processRequest(Object item){
              String processedItem = (String) item;
              // further processing
          }
        }
      description: In the insecure code example, the application receives a parameter from the request and assigns it to an Object variable. This causes a need to cast the object every time it is used, which is inefficient and could potentially lead to type confusion errors.
    steps:
      - Declare variables with the specific type they are expected to hold.
      - Use type-safe collections and generics to avoid the need for type casting.
    secure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletResponse;

        public class SecureController {
          public void handleRequest(
            HttpServletRequest request,
            HttpServletResponse response
          ) {
              String item = request.getParameter("item");
              processRequest(item);
          }

          private void processRequest(String item){
              // further processing
          }
        }
      description: In the secure code example, the application receives a parameter from the request and assigns it to a String variable. This ensures type safety and avoids the need for casting.
- title: Security Controls Bypass or Absence
  need: To prevent brute-force attacks and denial of service (DoS) attacks
  context:
    - Java (version 8 and above)
    - Web applications (MPA, SPA, API REST)
    - Using javax.servlet.http package for handling HTTP requests
    - Using Guava library for rate limiting
  vulnerability_id: "115"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletResponse;

        public class InsecureController {
          public void handleRequest(
            HttpServletRequest request,
            HttpServletResponse response
          ) {
              // Process the request without any rate limit
              // Rest of the code
          }
        }
      description: In this insecure code example, the application processes all incoming requests without applying any rate limit. This allows an attacker to send multiple requests to the server without control, potentially causing a denial of service (DoS) attack or brute-force attack.
    steps:
      - Implement rate limiting for incoming requests.
      - Use the Guava library's RateLimiter class to provide rate limiting functionality.
    secure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletResponse;
        import com.google.common.util.concurrent.RateLimiter;

        public class SecureController {
          private RateLimiter rateLimiter =
            RateLimiter.create(1.0);  // 1.0 represents one request per second

          public void handleRequest(
            HttpServletRequest request,
            HttpServletResponse response
          ) throws IOException {
              if(rateLimiter.tryAcquire()) {
                  // Process the request
                  // Rest of the code
              } else {
                  // Send response indicating too many requests
                  response.getWriter().write("Too many requests, please try again later.");
              }
          }
        }
      description: In this secure code example, the application uses Guava's RateLimiter to limit the number of requests that can be made per second. This helps to prevent brute-force attacks and denial of service (DoS) attacks.
- title: HTTP Parameter Pollution
  need: To prevent unwanted behavior caused by unexpected additional HTTP parameters
  context:
    - Java (version 8 and above)
    - Web applications (MPA, SPA, API REST)
    - Using javax.servlet.http package for handling HTTP requests
  vulnerability_id: "121"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletResponse;

        public class InsecureController {
          public void handleRequest(
            HttpServletRequest request,
            HttpServletResponse response
          ) {
              String action = request.getParameter("action");
              // Process the request based on the "action" parameter
              // Rest of the code
          }
        }
      description: In this insecure code example, the application takes an HTTP parameter ("action") and processes the request based on its value without checking for extra parameters. An attacker could inject additional "action" parameters into the request, which could cause the application to behave in unexpected ways.
    steps:
      - Validate the number of parameters in the request.
      - Reject requests that contain unexpected or additional parameters.
    secure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletResponse;

        public class SecureController {
          public void handleRequest(
            HttpServletRequest request,
            HttpServletResponse response
          ) throws IOException {
              if(request.getParameterValues("action").length > 1) {
                  // If there are multiple "action" parameters, reject the request
                  response.getWriter().write("Invalid request.");
                  return;
              }
              String action = request.getParameter("action");
              // Process the request based on the "action" parameter
              // Rest of the code
          }
        }
      description: In this secure code example, the application checks for multiple "action" parameters in the request. If multiple "action" parameters are found, the application rejects the request. This prevents an attacker from injecting additional "action" parameters into the request.
- title: Local File Inclusion
  need: To prevent unauthorized access and execution of local files through the manipulation of file paths in input fields.
  context:
    - Java (version 8 and above)
    - Web applications (MPA, SPA, API REST)
    - Using javax.servlet.http package for handling HTTP requests
  vulnerability_id: "123"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletResponse;
        import java.io.File;

        public class InsecureController {
          public void handleRequest(
            HttpServletRequest request,
            HttpServletResponse response
          ) throws IOException {
              String filename = request.getParameter("filename");
              File file = new File(filename);
              // Read and return the file content
              // Rest of the code
          }
        }
      description: In this insecure code example, the application directly uses the filename from an HTTP request parameter to access a file. This allows an attacker to manipulate the filename parameter to access sensitive files on the server.
    steps:
      - Do not use user input to construct file paths directly.
      - Validate user inputs to ensure they do not contain file paths or other unexpected values.
      - Use a secure method to resolve file paths, such as getCanonicalPath.
    secure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletResponse;
        import java.io.File;

        public class SecureController {
          private static final String BASE_DIRECTORY = "/safe/directory/";

          public void handleRequest(
            HttpServletRequest request,
            HttpServletResponse response
          ) throws IOException {
              String filename = request.getParameter("filename");

              // Validate the filename
              if (!filename.matches("^[a-zA-Z0-9_]+$")) {
                  response.getWriter().write("Invalid request.");
                  return;
              }

              File file = new File(BASE_DIRECTORY, filename);
              File canonicalFile = file.getCanonicalFile();

              if (!canonicalFile.getPath().startsWith(BASE_DIRECTORY)) {
                  response.getWriter().write("Invalid request.");
                  return;
              }

              // Read and return the file content
              // Rest of the code
          }
        }
      description: In this secure code example, the application validates the "filename" parameter to ensure it only contains alphanumeric characters and underscores. It then uses the "getCanonicalFile" method to resolve the absolute path of the file, and checks that the resolved path is still within the intended directory. This prevents an attacker from manipulating the filename parameter to access files outside of the intended directory.
- title: Race Condition
  need: To prevent unpredictable application behavior and potential security issues when multiple processes access shared data concurrently.
  context:
    - Java (version 8 and above)
    - Web applications (MPA, SPA, API REST)
    - Using javax.servlet.http package for handling HTTP requests
  vulnerability_id: "124"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletResponse;
        import java.io.File;

        public class InsecureController {
          public void handleRequest(
            HttpServletRequest request,
            HttpServletResponse response
          ) throws IOException {
              String filename = request.getParameter("filename");
              File file = new File(filename);

              // Check if file exists
              if (!file.exists()) {
                  // If not, create it
                  file.createNewFile();
              }

              // Rest of the code
          }
        }
      description: In this insecure code example, the application checks if a file exists and if not, it creates the file. However, between the check and the creation of the file, another process could create the file, leading to a race condition.
    steps:
      - Use synchronization to ensure that the check and creation of the file is an atomic operation.
      - Alternatively, use methods that check and create the file atomically.
    secure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletResponse;
        import java.io.File;
        import java.io.IOException;
        import java.nio.file.Files;
        import java.nio.file.Path;
        import java.nio.file.Paths;
        import java.nio.file.StandardOpenOption;

        public class SecureController {
          public void handleRequest(
            HttpServletRequest request,
            HttpServletResponse response
          ) throws IOException {
              String filename = request.getParameter("filename");
              Path path = Paths.get(filename);

              // Create the file atomically
              try {
                  Files.write(path, new byte[0], StandardOpenOption.CREATE_NEW);
              } catch (IOException e) {
                  // File already exists, handle appropriately
              }

              // Rest of the code
          }
        }
      description: In this secure code example, the application uses the `Files.write` method with the `StandardOpenOption.CREATE_NEW` option. This creates a new file, failing if the file already exists, thereby avoiding the race condition.
- title: Type Confusion
  need: To ensure type consistency and prevent incorrect processing or misinterpretation of data.
  context:
    - Java (version 8 and above)
    - Web applications (MPA, SPA, API REST)
    - Using javax.servlet.http package for handling HTTP requests
  vulnerability_id: "127"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletResponse;

        public class InsecureController {
          public void handleRequest(
            HttpServletRequest request,
            HttpServletResponse response
          ) {
              String value = request.getParameter("value");
              int number = Integer.decode(value);
              // Rest of the code
          }
        }
      description: In this insecure code example, the application accepts a string from the user and decodes it into an integer using Integer.decode method. This can lead to type confusion as the method accepts hexadecimal and octal strings as well, not just decimal numbers.
    steps:
      - Use Integer.parseInt instead of Integer.decode.
      - Additionally, validate the input to ensure it only contains decimal digits.
    secure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletResponse;

        public class SecureController {
          public void handleRequest(
            HttpServletRequest request,
            HttpServletResponse response
          ) {
              String value = request.getParameter("value");
              if (value.matches("\\d+")) {
                  int number = Integer.parseInt(value);
                  // Rest of the code
              } else {
                  // Handle invalid input
              }
          }
        }
      description: In this secure code example, the application first validates the input to ensure it only contains decimal digits. It then parses it into an integer using Integer.parseInt, which only accepts decimal numbers, thereby avoiding the type confusion.
- title: Insecurely Generated Cookies - Lack of HttpOnly Flag
  need: To ensure secure handling of cookies and prevent potential cross-site scripting (XSS) attacks.
  context:
    - Java (version 8 and above)
    - Web applications (MPA, SPA, API REST)
    - Using javax.servlet.http package for handling HTTP requests
  vulnerability_id: "128"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.http.Cookie;

        public class InsecureController {
          public void setCookie() {
              Cookie cookie = new Cookie("session", "12345");
              // Rest of the code
          }
        }
      description: In this insecure code example, a cookie is created but the HttpOnly attribute is not set. This makes the cookie accessible via client-side script, increasing the risk of a successful XSS attack.
    steps:
      - Set the HttpOnly attribute when creating the cookie.
    secure_code_example:
      text: |
        import javax.servlet.http.Cookie;

        public class SecureController {
          public void setCookie() {
              Cookie cookie = new Cookie("session", "12345");
              cookie.setHttpOnly(true);
              // Rest of the code
          }
        }
      description: In this secure code example, the HttpOnly attribute is set when creating the cookie. This makes the cookie inaccessible to client-side script, mitigating the risk of XSS attacks.
- title: Insecurely Generated Cookies - Lack of SameSite Attribute
  need: To ensure secure handling of cookies and prevent potential Cross-Site Request Forgery (CSRF) attacks.
  context:
    - Java (version 8 and above)
    - Web applications (MPA, SPA, API REST)
    - Using javax.servlet.http package for handling HTTP requests
  vulnerability_id: "129"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.http.Cookie;

        public class InsecureController {
          public void setCookie() {
              Cookie cookie = new Cookie("session", "12345");
              // Rest of the code
          }
        }
      description: In this insecure code example, a cookie is created but the SameSite attribute is not set. This makes the application vulnerable to CSRF attacks, where the attacker could trick a user into making a request that the user did not intend to make.
    steps:
      - Set the SameSite attribute when creating the cookie to "Strict" or "Lax" as appropriate.
    secure_code_example:
      text: |
        import javax.servlet.http.Cookie;

        public class SecureController {
          public void setCookie() {
              Cookie cookie = new Cookie("session", "12345");
              cookie.setSecure(true); // Always use secure cookies with the SameSite attribute
              response
              .setHeader("Set-Cookie", "session=12345; SameSite=Strict"); // Set the SameSite attribute to "Strict"
              // Rest of the code
          }
        }
      description: In this secure code example, the SameSite attribute is set when creating the cookie. This provides a level of protection against CSRF attacks by ensuring that the cookie will only be sent in a first-party context and not be sent along with requests initiated by third party websites.
- title: Insecurely Generated Cookies - Lack of Secure Attribute
  need: To ensure secure transmission of cookies and prevent potential Man-in-the-Middle (MitM) attacks.
  context:
    - Java (version 8 and above)
    - Web applications (MPA, SPA, API REST)
    - Using javax.servlet.http package for handling HTTP requests
  vulnerability_id: "130"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.http.Cookie;

        public class InsecureController {
          public void setCookie() {
              Cookie cookie = new Cookie("session", "12345");
              // Rest of the code
          }
        }
      description: In this insecure code example, a cookie is created but the Secure attribute is not set. This makes the application vulnerable to Man-in-the-Middle attacks, where the attacker could intercept the communication between the user and the server and steal the cookie.
    steps:
      - Set the Secure attribute when creating the cookie.
    secure_code_example:
      text: |
        import javax.servlet.http.Cookie;

        public class SecureController {
          public void setCookie() {
              Cookie cookie = new Cookie("session", "12345");
              cookie.setSecure(true); // Always use secure cookies
              // Rest of the code
          }
        }
      description: In this secure code example, the Secure attribute is set when creating the cookie. This provides a level of protection against Man-in-the-Middle attacks by ensuring that the cookie will only be sent over secure (HTTPS) connections.
- title: Insecure or Unset HTTP Headers - Lack of Strict Transport Security
  need: To ensure that the application communicates only over secure (HTTPS) connections.
  context:
    - Java (version 8 and above)
    - Web applications (MPA, SPA, API REST)
    - Using javax.servlet.http package for handling HTTP requests
  vulnerability_id: "131"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.http.HttpServletResponse;

        public class InsecureController {
          public void doGet(HttpServletRequest request, HttpServletResponse response) {
              // Rest of the code
              // Note: No Strict-Transport-Security header is set
          }
        }
      description: In this insecure code example, the server's response does not set the Strict-Transport-Security HTTP header, which is a security flaw. Without this header, the application might communicate over insecure (HTTP) connections, making it vulnerable to Man-in-the-Middle attacks.
    steps:
      - Set the Strict-Transport-Security header in all server responses.
      - Set the max-age of the Strict-Transport-Security header to at least 31536000 seconds (one year).
    secure_code_example:
      text: |
        import javax.servlet.http.HttpServletResponse;

        public class SecureController {
          public void doGet(HttpServletRequest request, HttpServletResponse response) {
              response.setHeader("Strict-Transport-Security", "max-age=31536000; includeSubDomains");
              // Rest of the code
          }
        }
      description: In this secure code example, the server's response sets the Strict-Transport-Security HTTP header, forcing the browser to communicate over secure (
- title: Insecure or Unset HTTP Headers - Improper CORS Settings
  need: To prevent resources from being loaded from untrusted domains.
  context:
    - Java (version 8 and above)
    - Web applications (MPA, SPA, API REST)
    - Using javax.servlet.http package for handling HTTP requests
  vulnerability_id: "134"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.http.HttpServletResponse;

        public class InsecureController {
          public void doGet(HttpServletRequest request, HttpServletResponse response) {
              response.setHeader("Access-Control-Allow-Origin", "*");
              // Rest of the code
          }
        }
      description: In this insecure code example, the server's response sets the Access-Control-Allow-Origin HTTP header to "*", which means that any domain is allowed to share resources with the application. This can potentially allow an attacker to load resources from untrusted domains.
    steps:
      - Remove the wildcard (*) from the Access-Control-Allow-Origin header.
      - Define explicitly the trusted origins that are allowed to share resources with the application.
    secure_code_example:
      text: |
        import javax.servlet.http.HttpServletResponse;

        public class SecureController {
          public void doGet(HttpServletRequest request, HttpServletResponse response) {
              response.setHeader("Access-Control-Allow-Origin", "https://trusteddomain.com");
              // Rest of the code
          }
        }
      description: In this secure code example, the server's response sets the Access-Control-Allow-Origin HTTP header to a specific trusted domain. This ensures that only resources from this trusted domain are allowed to be shared with the application, preventing potential attacks from untrusted domains.
- title: Inappropriate Coding Practices - Public Class Fields
  need: To maintain the encapsulation principle and prevent unauthorized access and modifications to class attributes.
  context:
    - Java (version 8 and above)
    - All types of applications (Web MPA, Web SPA, API REST, API GraphQL, etc.)
    - General object-oriented programming context
  vulnerability_id: "138"
  solution:
    language: java
    insecure_code_example:
      text: |
        public class InsecureClass {
          public String sensitiveData;
          // Rest of the class
        }
      description: In this insecure code example, the class field 'sensitiveData' is public, which means it can be accessed and modified from outside of the class. This does not respect the encapsulation principle of object-oriented programming and can lead to unauthorized access and modifications.
    steps:
      - Set the class fields to private.
      - Generate getter and setter methods to access and modify them in a controlled way.
    secure_code_example:
      text: |
        public class SecureClass {
          private String sensitiveData;

          public String getSensitiveData() {
            return this.sensitiveData;
          }

          public void setSensitiveData(String sensitiveData) {
            this.sensitiveData = sensitiveData;
          }
          // Rest of the class
        }
      description: In this secure code example, the class field 'sensitiveData' is private and can only be accessed and modified via its getter and setter methods. This respects the encapsulation principle of object-oriented programming and prevents unauthorized access and modifications.
- title: Insecure Exceptions Handling - Empty or No Catch
  need: To ensure application availability and maintain error traceability.
  context:
    - Java (version 8 and above)
    - All types of applications (Web MPA, Web SPA, API REST, API GraphQL, etc.)
    - General exception handling in Java
  vulnerability_id: "140"
  solution:
    language: java
    insecure_code_example:
      text: |
        public class InsecureExceptionHandling {
          public void riskyMethod() {
            try {
              // Some risky operation
            } catch (Exception e) {
              // Empty catch block
            }
          }
        }
      description: In this insecure code example, a risky operation is performed in the try block, and any exceptions that occur are caught and ignored. This can lead to unhandled errors and loss of error traceability.
    steps:
      - Avoid empty catch blocks. At the very least, log the exception.
      - Catch specific exceptions instead of the generic Exception class if possible, as this can provide more precise error information.
      - Consider whether the catch block should take some action in response to the exception, such as cleaning up resources, alerting the user, or propagating the exception to a higher level in the application.
    secure_code_example:
      text: |
        public class SecureExceptionHandling {
          public void riskyMethod() {
            try {
              // Some risky operation
            } catch (SpecificException e) {
              System.err.println("An error occurred: " + e.getMessage());
              // Additional error handling code
            }
          }
        }
      description: In this secure code example, the risky operation is still performed in the try block, but now the catch block catches a specific type of exception, logs an error message, and may perform additional error handling actions. This improves error traceability and application resilience.
- title: Lack of Data Validation - URL Parameters
  need: To ensure privacy and confidentiality of user information.
  context:
    - Java (version 8 and above)
    - All types of web applications (Web MPA, Web SPA, API REST, etc.)
    - Servlets and URL parameters handling
  vulnerability_id: "141"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.*;
        import javax.servlet.http.*;
        import java.io.IOException;

        public class InsecureServlet extends HttpServlet {
          protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            String date = request.getParameter("date");
            // Fetching data based on the 'date' parameter without any validation
          }
        }
      description: In this insecure code example, the servlet fetches data based on a 'date' parameter taken directly from the URL without any validation or access control. This allows any user to obtain information about others by changing the 'date' parameter in the URL.
    steps:
      - Validate URL parameters before using them.
      - Implement access controls to ensure only authorized users can access certain data.
      - Implement user sessions to identify and authenticate users before serving them sensitive data.
    secure_code_example:
      text: |
        import javax.servlet.*;
        import javax.servlet.http.*;
        import java.io.IOException;

        public class SecureServlet extends HttpServlet {
          protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            HttpSession session = request.getSession(false);
            if (session != null && session.getAttribute("username") != null) {
              String date = request.getParameter("date");
              // Validate the 'date' parameter and fetch data
            } else {
              response.sendRedirect("login.jsp"); // Not logged in, redirect to login page
            }
          }
        }
      description: In this secure code example, the servlet first checks if the user is logged in by checking their session. If they are not logged in, they are redirected to the login page. Only after verifying the user's login status does the servlet fetch data based on the 'date' parameter. This ensures that only authorized, logged-in users can access the data.
- title: Inappropriate Coding Practices - Misuse of eval() Function
  need: To prevent remote code execution and maintain the application's security.
  context:
    - Java (version 8 and above)
    - All types of web applications (Web MPA, Web SPA, API REST, etc.)
    - Servlets and dynamic code execution
  vulnerability_id: "143"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.script.ScriptEngine;
        import javax.script.ScriptEngineManager;
        import javax.servlet.*;
        import javax.servlet.http.*;
        import java.io.IOException;

        public class InsecureServlet extends HttpServlet {
          protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            String expression = request.getParameter("expression");
            ScriptEngineManager manager = new ScriptEngineManager();
            ScriptEngine engine = manager.getEngineByName("JavaScript");
            try {
              Object result = engine.eval(expression);
              // Do something with the result
            } catch (Exception e) {
              // Handle exception
            }
          }
        }
      description: In this insecure code example, the servlet takes a parameter from the URL and evaluates it as a JavaScript expression using the `eval()` function. This allows a user to inject arbitrary code into the 'expression' parameter, potentially leading to remote code execution or other security risks.
    steps:
      - Avoid the use of the `eval()` function whenever possible.
      - If dynamic code execution is necessary, validate and sanitize the input thoroughly before passing it to `eval()`.
      - Consider using less risky alternatives to `eval()`, such as parsers or compilers designed for the specific task you're trying to accomplish.
    secure_code_example:
      text: |
        import javax.servlet.*;
        import javax.servlet.http.*;
        import java.io.IOException;

        public class SecureServlet extends HttpServlet {
          protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            String expression = request.getParameter("expression");
            // Validate and sanitize the 'expression' parameter before using it
            if (isValidExpression(expression)) {
              // Only use 'expression' in a safe way if it's valid
            } else {
              // Handle invalid 'expression'
            }
          }

          private boolean isValidExpression(String expression) {
            // Implement a robust validation and sanitization process
            return true;
          }
        }
      description: In this secure code example, the servlet first validates and sanitizes the 'expression' parameter before using it. This helps prevent the execution of arbitrary or malicious code.
- title: Inappropriate Coding Practices - Overuse of Static Import
  need: To maintain readability and understandability of the code.
  context:
    - Java (version 5 and above)
    - All types of applications (Web MPA, Web SPA, API REST, etc.)
    - Cases where static members of a class are used frequently
  vulnerability_id: "144"
  solution:
    language: java
    insecure_code_example:
      text: |
        import static java.lang.Math.*;

        public class InsecureStaticImport {
            public double calculateArea(double radius) {
                return PI * pow(radius, 2);
            }
        }
      description: In this insecure code example, the Math class's static members are imported using a static import. This makes the code less readable because it's not immediately clear where 'PI' and 'pow()' are defined.
    steps:
      - Avoid using static imports for basic functions or constants.
      - If you need to use a static member frequently, consider importing the class normally and referencing the static member with class qualification.
      - Remember that code readability is important for maintainability and understanding by other developers.
    secure_code_example:
      text: |
        import java.lang.Math;

        public class SecureStaticImport {
            public double calculateArea(double radius) {
                return Math.PI * Math.pow(radius, 2);
            }
        }
      description: In this secure code example, the Math class is imported normally. When the static members 'PI' and 'pow()' are used, they are qualified with 'Math', making it clear where they're defined.
- title: Inappropriate Coding Practices - High Cyclomatic Complexity
  need: To improve code readability, maintainability, and reduce the risk of introducing errors.
  context:
    - Java (all versions)
    - All types of applications (Web MPA, Web SPA, API REST, etc.)
    - When there is a method with a large number of conditional logic
  vulnerability_id: "145"
  solution:
    language: java
    insecure_code_example:
      text: |
        public class InsecureComplexity {
            public void complexMethod(int a, int b, int c, int d, int e, int f) {
                if(a > b) {
                    if(b > c) {
                        if(c > d) {
                            if(d > e) {
                                if(e > f) {
                                    System.out.println("All conditions met");
                                }
                            }
                        }
                    }
                }
            }
        }
      description: In this insecure code example, the method 'complexMethod' has a high cyclomatic complexity due to the nested if conditions. This makes the code hard to read and maintain.
    steps:
      - Break down the complex method into smaller, more manageable methods.
      - Avoid deep nesting of conditions, and aim for a linear flow as much as possible.
      - Consider using design patterns, like Strategy pattern, to handle complex conditional logic.
    secure_code_example:
      text: |
        public class SecureComplexity {
            public boolean isGreater(int x, int y) {
                return x > y;
            }

            public void simplifiedMethod(int a, int b, int c, int d, int e, int f) {
                if(isGreater(a, b) && isGreater(b, c) && isGreater(c, d) && isGreater(d, e) && isGreater(e, f)) {
                    System.out.println("All conditions met");
                }
            }
        }
      description: In this secure code example, the complex conditional logic is broken down into smaller, more manageable methods, reducing the cyclomatic complexity and improving readability.
- title: Time-based SQL Injection
  need: To prevent unauthorized access and manipulation of data in the database.
  context:
    - Java (all versions)
    - All types of applications (Web MPA, Web SPA, API REST, etc.)
    - When handling data from user inputs to form SQL queries
  vulnerability_id: "154"
  solution:
    language: java
    insecure_code_example:
      text: |
        import java.sql.*;

        public class InsecureServlet extends HttpServlet {
            protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                String id = request.getParameter("id");
                String query = "SELECT * FROM users WHERE id = " + id;

                try {
                    Statement stmt = connection.createStatement();
                    ResultSet rs = stmt.executeQuery(query);
                    //...
                } catch (SQLException e) {
                    //...
                }
            }
        }
      description: In this insecure code example, the SQL query is constructed by concatenating a string directly with user input. An attacker could manipulate the 'id' parameter to inject a malicious SQL statement that causes a delay, allowing them to infer information about the database structure.
    steps:
      - Use prepared statements with parameterized queries to ensure that user input is not executed as SQL commands.
      - Use input validation to check for unexpected characters or patterns in user input.
      - Limit the privileges of the database account used by the application to only what's necessary.
    secure_code_example:
      text: |
        import java.sql.*;

        public class SecureServlet extends HttpServlet {
            protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                String id = request.getParameter("id");
                String query = "SELECT * FROM users WHERE id = ?";

                try {
                    PreparedStatement pstmt = connection.prepareStatement(query);
                    pstmt.setString(1, id);
                    ResultSet rs = pstmt.executeQuery();
                    //...
                } catch (SQLException e) {
                    //...
                }
            }
        }
      description: In this secure code example, a prepared statement with a parameterized query is used. This ensures that the 'id' parameter is treated as a literal value, not part of the SQL command, preventing SQL injection attacks.
- title: Insecure Service Configuration - Keys
  need: To prevent unauthorized access and manipulation of data due to the exposure of cipher keys.
  context:
    - Java (all versions)
    - All types of applications (Web MPA, Web SPA, API REST, etc.)
    - When handling sensitive keys directly in the source code
  vulnerability_id: "169"
  solution:
    language: java
    insecure_code_example:
      text: |
        public class InsecureServiceConfig {
            // Insecurely storing keys directly in code
            private static final String SECRET_KEY = "my-very-secret-key";

            public void doSomethingSensitive() {
                // Use secret key...
            }
        }
      description: In this insecure code example, a secret key is stored directly in the source code. If the source code is compromised or inadvertently made public, this key can be used by attackers.
    steps:
      - Do not store sensitive keys directly in the source code.
      - Use secure storage solutions for sensitive keys, such as Java KeyStore.
      - Ensure the key is only accessible to authorized entities.
    secure_code_example:
      text: |
        import java.security.KeyStore;

        public class SecureServiceConfig {
            // Retrieve keys from secure KeyStore
            private KeyStore keyStore;

            public SecureServiceConfig() {
                try {
                    keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
                    // Load KeyStore...
                } catch (Exception e) {
                    // Handle exception...
                }
            }

            public void doSomethingSensitive() {
                try {
                    KeyStore.SecretKeyEntry secretKeyEntry = (KeyStore.SecretKeyEntry) keyStore.getEntry("mykey", null);
                    // Use secret key...
                } catch (Exception e) {
                    // Handle exception...
                }
            }
        }
      description: In this secure code example, the secret key is stored in a Java KeyStore, which is a secure way of storing cryptographic keys.
- title: Unauthorized Access to Files
  need: To prevent unauthorized access and manipulation of data through file inclusion vulnerabilities.
  context:
    - Java (all versions)
    - All types of applications (Web MPA, Web SPA, API REST, etc.)
    - When handling file requests without properly validating and sanitizing input data
  vulnerability_id: "201"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.*;
        import javax.servlet.http.*;
        import java.io.*;

        public class VulnerableServlet extends HttpServlet {
            public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                String filename = request.getParameter("filename");
                FileInputStream fis = new FileInputStream("/secure/files/" + filename);
                // Process file...
            }
        }
      description: In this insecure code example, the servlet reads a file based on user input without any validation. An attacker can manipulate the filename parameter to access any files on the server.
    steps:
      - Validate the user input to ensure it does not contain unauthorized access paths.
      - Use a whitelist of allowed files and reject any request for files not on this list.
      - Configure the server to restrict file access to certain directories.
    secure_code_example:
      text: |
        import javax.servlet.*;
        import javax.servlet.http.*;
        import java.io.*;

        public class SecureServlet extends HttpServlet {
            public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                String filename = request.getParameter("filename");
                if (filename.contains("..") || filename.contains("/") || filename.contains("\\")) {
                    response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid file requested");
                    return;
                }
                FileInputStream fis = new FileInputStream("/secure/files/" + filename);
                // Process file...
            }
        }
      description: In this secure code example, the servlet validates the filename parameter before using it. If the filename contains any directory traversal characters, the request is rejected. This prevents an attacker from accessing files outside of the intended directory.
- title: Insufficient Data Authenticity Validation
  need: To ensure that only valid and authorized data is accepted and processed by the application.
  context:
    - Java (all versions)
    - All types of applications (Web MPA, Web SPA, API REST, etc.)
    - When handling user input data without proper authenticity validation
  vulnerability_id: "204"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.*;
        import javax.servlet.http.*;

        public class InsecureServlet extends HttpServlet {
            protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                String name = request.getParameter("name");
                // Process name without any validation...
            }
        }
      description: In this insecure code example, the servlet accepts and processes a name parameter from the request without any validation. This can allow an attacker to inject potentially malicious characters.
    steps:
      - Implement server-side input validation to check the authenticity of the data.
      - Use a library or framework that automatically escapes special characters to prevent injection attacks.
      - As a best practice, also implement client-side validation, but don't rely on it as the only form of data validation.
    secure_code_example:
      text: |
        import javax.servlet.*;
        import javax.servlet.http.*;
        import org.apache.commons.lang.StringEscapeUtils;

        public class SecureServlet extends HttpServlet {
            protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                String name = request.getParameter("name");
                name = StringEscapeUtils.escapeHtml(name);
                // Process name after validation...
            }
        }
      description: In this secure code example, the servlet validates the name parameter by escaping any special characters that can be used for injection attacks. This can prevent an attacker from injecting malicious characters into the name field.
- title: Insecure Functionality - Unchecked File Creation
  need: To prevent unauthorized access and modification of user data.
  context:
    - Java 8 and above
    - All types of applications (Web MPA, Web SPA, API REST, etc.)
    - When server-side validation of user permissions is not implemented
  vulnerability_id: "270"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.*;
        import javax.servlet.http.*;
        import java.io.*;

        public class InsecureFileCreation extends HttpServlet {
            public void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {

                String filename = request.getParameter("filename");
                String content = request.getParameter("content");

                // No check if the user has sufficient permissions
                try (PrintWriter out = new PrintWriter(new FileOutputStream(new File(filename), true))) {
                    out.println(content);
                }
            }
        }
      description: In this insecure scenario, the server-side does not verify if the user has sufficient permissions to create files. Even if the client-side disables the corresponding function for certain users, they can still bypass it and make the server process the query.
    steps:
      - Implement server-side validation to check if the user has the necessary permissions to perform the action.
      - Don't rely solely on client-side validation because it can be easily bypassed.
    secure_code_example:
      text: |
        import javax.servlet.*;
        import javax.servlet.http.*;
        import java.io.*;

        public class SecureFileCreation extends HttpServlet {
            public void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {

                String filename = request.getParameter("filename");
                String content = request.getParameter("content");
                User user = (User) request.getSession().getAttribute("authenticatedUser");

                // Check if the user has sufficient permissions
                if (user.hasPermission("CREATE_FILE")) {
                    try (PrintWriter out = new PrintWriter(new FileOutputStream(new File(filename), true))) {
                        out.println(content);
                    }
                } else {
                    response.sendError(HttpServletResponse.SC_FORBIDDEN, "You don't have permission to perform this action");
                }
            }
        }
      description: In this secure scenario, the server-side verifies if the user has the necessary permissions to create files. This way, even if a user bypasses the client-side restrictions, the server will still not process unauthorized queries.
- title: Insecure Password Management
  need: To prevent unauthorized users from changing other users' passwords.
  context:
    - Java 8 and above
    - All types of applications (Web MPA, Web SPA, API REST, etc.)
    - When server-side validation of user permissions for password changes is not implemented
  vulnerability_id: "271"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.*;
        import javax.servlet.http.*;
        import java.io.*;

        public class InsecurePasswordChange extends HttpServlet {
            public void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {

                String targetUsername = request.getParameter("username");
                String newPassword = request.getParameter("newPassword");

                // No check if the user is changing their own password
                UserService.changePassword(targetUsername, newPassword);
            }
        }
      description: In this insecure scenario, the server-side does not verify if the user is changing their own password. This could allow a user to change the password of another user if they can guess or know their username.
    steps:
      - Implement server-side validation to check if the user is changing their own password.
      - Don't rely solely on client-side validation because it can be easily bypassed.
    secure_code_example:
      text: |
        import javax.servlet.*;
        import javax.servlet.http.*;
        import java.io.*;

        public class SecurePasswordChange extends HttpServlet {
            public void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {

                String targetUsername = request.getParameter("username");
                String newPassword = request.getParameter("newPassword");
                User user = (User) request.getSession().getAttribute("authenticatedUser");

                // Check if the user is changing their own password
                if (user.getUsername().equals(targetUsername)) {
                    UserService.changePassword(targetUsername, newPassword);
                } else {
                    response.sendError(HttpServletResponse.SC_FORBIDDEN, "You don't have permission to perform this action");
                }
            }
        }
      description: In this secure scenario, the server-side verifies if the user is changing their own password. This way, even if a user tries to change another user's password, the server will not process the unauthorized query.
- title: Insecure Functionality - Fingerprint
  need: To ensure data integrity by preventing unsolicited user data updates.
  context:
    - Java 8 and later versions
    - Web MPA, Web SPA, API REST
    - Servlet-based web applications using javax.servlet package
  vulnerability_id: "273"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.*;
        import javax.servlet.http.*;

        public class VulnerableServlet extends HttpServlet {
            public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                User user = getUserFromSession(request);
                if (user != null) {
                    String updatedEmail = request.getParameter("email");
                    String updatedUsername = request.getParameter("username");
                    // Updating all fields without checking
                    user.setEmail(updatedEmail);
                    user.setUsername(updatedUsername);
                }
            }
        }
      description: The servlet updates the user's email and username just based on the parameters received in the request. An attacker could potentially provide any values for these parameters, leading to unsolicited user data updates.
    steps:
      - Validate user inputs before processing them.
      - Check the necessity and validity of each update operation.
      - Make sure to only update those fields that have been explicitly requested by the user.
    secure_code_example:
      text: |
        import javax.servlet.*;
        import javax.servlet.http.*;
        import java.util.regex.Matcher;
        import java.util.regex.Pattern;

        public class SecureServlet extends HttpServlet {
            private static final String EMAIL_PATTERN = "^[_A-Za-z0-9-\\+]+(\\.[_A-Za-z0-9-]+)*@" + "[A-Za-z0-9-]+(\\.[A-Za-z0-9]+)*(\\.[A-Za-z]{2,})$";
            private static final String USERNAME_PATTERN = "^[a-zA-Z0-9._-]{3,}$";

            public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                User user = getUserFromSession(request);
                if (user != null) {
                    String updatedEmail = request.getParameter("email");
                    String updatedUsername = request.getParameter("username");
                    // Updating only after checking
                    if (validateEmail(updatedEmail)) {
                        user.setEmail(updatedEmail);
                    }
                    if (validateUsername(updatedUsername)) {
                        user.setUsername(updatedUsername);
                    }
                }
            }

            private boolean validateEmail(String email) {
                Pattern pattern = Pattern.compile(EMAIL_PATTERN);
                Matcher matcher = pattern.matcher(email);
                return matcher.matches();
            }

            private boolean validateUsername(String username) {
                Pattern pattern = Pattern.compile(USERNAME_PATTERN);
                Matcher matcher = pattern.matcher(username);
                return matcher.matches();
            }
        }
      description: The servlet now validates the email and username before updating them. If an attacker attempts to provide invalid values, the validation logic will prevent these values from being saved.
- title: Insecure Exceptions - NullPointerException
  need: To prevent unexpected behavior and potential denial of service due to improper handling of NullPointerExceptions.
  context:
    - Java 8 and later versions
    - Web MPA, Web SPA, API REST
    - Servlet-based web applications using javax.servlet package
  vulnerability_id: "278"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.*;
        import javax.servlet.http.*;

        public class VulnerableServlet extends HttpServlet {
            public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                try {
                    String param = request.getParameter("param");
                    processParam(param);
                } catch (NullPointerException e) {
                    // Doing nothing
                }
            }

            private void processParam(String param) {
                // Some processing here which could potentially throw NullPointerException
            }
        }
      description: The servlet catches NullPointerException but does nothing about it. This could lead to unexpected behavior if a null parameter is passed, as the processParam method may rely on param being non-null.
    steps:
      - Avoid catching NullPointerException. Instead, check for null values before using objects.
      - Handle exceptions properly in catch blocks, by logging, notifying the user, or taking other appropriate actions.
    secure_code_example:
      text: |
        import javax.servlet.*;
        import javax.servlet.http.*;

        public class SecureServlet extends HttpServlet {
            public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                String param = request.getParameter("param");
                if (param != null) {
                    processParam(param);
                } else {
                    // Handle the case where param is null, such as returning an error response.
                }
            }

            private void processParam(String param) {
                // Some processing here
            }
        }
      description: The servlet now checks if param is null before calling the processParam method, ensuring that NullPointerException will not be thrown.
- title: Root Detection Control Bypass
  need: To prevent reverse engineering or manipulation of the application on rooted devices.
  context:
    - Java
    - Android applications
  vulnerability_id: "279"
  solution:
    language: java
    insecure_code_example:
      text: |
        public class MainActivity extends AppCompatActivity {

            @Override
            protected void onCreate(Bundle savedInstanceState) {
                super.onCreate(savedInstanceState);
                setContentView(R.layout.activity_main);

                if (isDeviceRooted()) {
                    // allow some functionality
                }
            }

            public static boolean isDeviceRooted() {
                String su = "su";
                String[] locations = {"/sbin/", "/system/bin/", "/system/xbin/", "/data/local/xbin/",
                        "/data/local/bin/", "/system/sd/xbin/", "/system/bin/failsafe/", "/data/local/"};
                for (String location : locations) {
                    if (new File(location + su).exists()) {
                        return true;
                    }
                }
                return false;
            }
        }
      description: This code is checking for root by looking for the su binary in various locations. This check can be bypassed by an attacker by simply moving the su binary to a different location.
    steps:
      - Avoid relying solely on root detection for security.
      - Implement multiple levels of security including server-side checks, SSL pinning, code obfuscation, etc.
      - Implement tamper detection to check if the APK has been modified.
    secure_code_example:
      text: |
        // It is recommended not to rely solely on root detection,
        // instead focus on securing data and communication, like using encryption, SSL pinning, etc.
        // Here is a very basic example of how you might add a simple tamper detection

        public class MainActivity extends AppCompatActivity {

            // A real hash should be a hash of your APK signature
            private static final String REAL_APK_HASH = "your_real_hash_here";

            @Override
            protected void onCreate(Bundle savedInstanceState) {
                super.onCreate(savedInstanceState);
                setContentView(R.layout.activity_main);

                if (isApkTampered()) {
                    // Stop the app, the APK has been tampered with
                    finish();
                }

                if (isDeviceRooted()) {
                    // allow some functionality
                }
            }

            public static boolean isDeviceRooted() {
                // same as before
            }

            public static boolean isApkTampered() {
                String currentApkHash = getCurrentApkHash();
                return !REAL_APK_HASH.equals(currentApkHash);
            }

            public static String getCurrentApkHash() {
                // get the current APK hash
                // Implementation depends on the hash function used
                return "";
            }
        }
      description: In this secure code example, tamper detection is added in addition to the root detection. This is a very basic form of tamper detection, which can also be bypassed by a knowledgeable attacker. It is advised to use more sophisticated methods in a production application.
- title: Session Fixation
  need: To prevent unauthorized users from hijacking a legitimate user's session.
  context:
    - Java
    - Web applications (Web MPA, Web SPA, API REST, etc.)
    - javax.servlet and javax.servlet.http
  vulnerability_id: "280"
  solution:
    language: java
    insecure_code_example:
      text: |
        @WebServlet("/login")
        public class LoginServlet extends HttpServlet {
            protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                String username = request.getParameter("username");
                String password = request.getParameter("password");

                if (isValidUser(username, password)) {
                    HttpSession session = request.getSession();
                    session.setAttribute("username", username);
                    // Redirect to user home
                } else {
                    // Redirect to login
                }
            }

            private boolean isValidUser(String username, String password) {
                // Validate the username and password against stored values
                return true;
            }
        }
      description: In this code, when a user logs in, the session ID they started with continues to be used even after login. This exposes the user to Session Fixation attacks.
    steps:
      - Invalidate the current session after successful login.
      - Create a new session for the user.
    secure_code_example:
      text: |
        @WebServlet("/login")
        public class LoginServlet extends HttpServlet {
            protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                String username = request.getParameter("username");
                String password = request.getParameter("password");

                if (isValidUser(username, password)) {
                    HttpSession oldSession = request.getSession(false);
                    if (oldSession != null) {
                        oldSession.invalidate();
                    }
                    HttpSession newSession = request.getSession(true);
                    newSession.setAttribute("username", username);
                    // Redirect to user home
                } else {
                    // Redirect to login
                }
            }

            private boolean isValidUser(String username, String password) {
                // Validate the username and password against stored values
                return true;
            }
        }
      description: In the secure code example, the old session is invalidated after successful login and a new session is created. This prevents session fixation attacks.
- title: Insecure Direct Object References - Personal Information
  need: To ensure that users can only access and modify their own information, preserving privacy and integrity of data.
  context:
    - Java
    - Web applications (Web MPA, Web SPA, API REST, etc.)
    - javax.servlet and javax.servlet.http
  vulnerability_id: "286"
  solution:
    language: java
    insecure_code_example:
      text: |
        @WebServlet("/updateProfile")
        public class ProfileServlet extends HttpServlet {
            protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                String userId = request.getParameter("userId");
                String email = request.getParameter("email");

                User user = Database.getUserById(userId);
                user.setEmail(email);
                Database.updateUser(user);

                // Redirect to user profile
            }
        }
      description: In this code, the user ID is taken directly from the request parameters and used to get and update the user's information. An attacker could manipulate the 'userId' parameter to modify another user's data.
    steps:
      - Remove the user ID from request parameters.
      - Get the user ID from the session after successful authentication.
    secure_code_example:
      text: |
        @WebServlet("/updateProfile")
        public class ProfileServlet extends HttpServlet {
            protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                HttpSession session = request.getSession(false);
                if (session != null && session.getAttribute("userId") != null) {
                    String userId = session.getAttribute("userId").toString();
                    String email = request.getParameter("email");

                    User user = Database.getUserById(userId);
                    user.setEmail(email);
                    Database.updateUser(user);

                    // Redirect to user profile
                } else {
                    // Redirect to login
                }
            }
        }
      description: In the secure code example, the user ID is taken from the session, which is established after successful authentication
- title: Insecure Direct Object References - Corporate Information
  need: To validate user permissions for manipulating corporate data to preserve integrity and confidentiality of data.
  context:
    - Java
    - Web applications (Web MPA, Web SPA, API REST, etc.)
    - javax.servlet and javax.servlet.http
  vulnerability_id: "287"
  solution:
    language: java
    insecure_code_example:
      text: |
        @WebServlet("/uploadEmployeeData")
        public class UploadEmployeeDataServlet extends HttpServlet {
            protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                String payrollNumber = request.getParameter("payrollNumber");
                Part filePart = request.getPart("file");

                // Assume parseExcelFile function parses the Excel file and updates the database
                boolean result = Database.parseExcelFile(payrollNumber, filePart.getInputStream());

                // Redirect based on the result
            }
        }
      description: In this code, the payroll number (representing a company) is taken directly from the request parameters. An attacker can manipulate this payroll number to upload or modify employee data of a company to which they do not have access.
    steps:
      - Verify the payroll number with the list of companies the authenticated user has access to before processing the file.
    secure_code_example:
      text: |
        @WebServlet("/uploadEmployeeData")
        public class UploadEmployeeDataServlet extends HttpServlet {
            protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                HttpSession session = request.getSession(false);
                if (session != null && session.getAttribute("userId") != null) {
                    String userId = session.getAttribute("userId").toString();
                    String payrollNumber = request.getParameter("payrollNumber");

                    // Verify if the user has access to the company
                    if(Database.verifyUserAccessToCompany(userId, payrollNumber)){
                        Part filePart = request.getPart("file");

                        // Assume parseExcelFile function parses the Excel file and updates the database
                        boolean result = Database.parseExcelFile(payrollNumber, filePart.getInputStream());

                        // Redirect based on the result
                    } else {
                        // Redirect to error page
                    }
                } else {
                    // Redirect to login
                }
            }
        }
      description: In the secure code example, before processing the Excel file, the server verifies if the authenticated user has the permission to manipulate data of the company associated with the provided payroll number. This protects the data integrity and confidentiality of the companies.
- title: Insecure Direct Object References - Financial Information
  need: To ensure proper access control for financial data to prevent unauthorized access and protect sensitive data.
  context:
    - Java
    - Web applications (Web MPA, Web SPA, API REST, etc.)
    - javax.servlet and javax.servlet.http
  vulnerability_id: "288"
  solution:
    language: java
    insecure_code_example:
      text: |
        @WebServlet("/getCardDetails")
        public class GetCardDetailsServlet extends HttpServlet {
            protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                String encryptedCardNumber = request.getParameter("encryptedCardNumber");

                // Decrypt the card number
                String cardNumber = Encryption.decrypt(encryptedCardNumber);

                // Assume getCardDetails function gets the card details from the database
                String cardDetails = Database.getCardDetails(cardNumber);

                // Send the card details to the user
            }
        }
      description: In this code, the card number is taken directly from the request parameters and decrypted. This allows any authenticated user to request information about any card by supplying the encrypted card number. This can lead to unauthorized access to financial information.
    steps:
      - Verify the user's access rights to the card before processing the request.
    secure_code_example:
      text: |
        @WebServlet("/getCardDetails")
        public class GetCardDetailsServlet extends HttpServlet {
            protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                HttpSession session = request.getSession(false);
                if (session != null && session.getAttribute("userId") != null) {
                    String userId = session.getAttribute("userId").toString();
                    String encryptedCardNumber = request.getParameter("encryptedCardNumber");

                    // Decrypt the card number
                    String cardNumber = Encryption.decrypt(encryptedCardNumber);

                    // Verify if the user has access to the card
                    if(Database.verifyUserAccessToCard(userId, cardNumber)){
                        // Assume getCardDetails function gets the card details from the database
                        String cardDetails = Database.getCardDetails(cardNumber);

                        // Send the card details to the user
                    } else {
                        // Redirect to error page
                    }
                } else {
                    // Redirect to login
                }
            }
        }
      description: In the secure code, before fetching the card details, the server verifies if the authenticated user has the permission to access data related to the provided card number. This protects the financial data from being accessed by unauthorized users.
- title: Inappropriate Coding Practices - Public Variables
  need: To ensure data encapsulation and maintain the integrity of the data by protecting variables from being accessed or manipulated directly from outside the class.
  context:
    - Java
    - All type of applications (Web MPA, Web SPA, API REST, API GraphQL, etc.)
    - javax.servlet and javax.servlet.http
  vulnerability_id: "292"
  solution:
    language: java
    insecure_code_example:
      text: |
        public class User {
            public String username;
            public String password;

            public User(String username, String password) {
                this.username = username;
                this.password = password;
            }
        }
      description: The `username` and `password` are declared as public in the `User` class. This allows any part of the program to directly access or modify these variables, which can lead to data integrity issues and potential security vulnerabilities.
    steps:
      - Declare variables as private.
      - Use getter and setter methods to control how variables are accessed and modified.
    secure_code_example:
      text: |
        public class User {
            private String username;
            private String password;

            public User(String username, String password) {
                this.username = username;
                this.password = password;
            }

            public String getUsername() {
                return this.username;
            }

            public void setUsername(String username) {
                this.username = username;
            }

            public String getPassword() {
                return this.password;
            }

            public void setPassword(String password) {
                this.password = password;
            }
        }
      description: In the secure code, `username` and `password` are declared as private and can only be accessed or modified using getter and setter methods. This ensures that these variables are encapsulated and only modified under controlled circumstances, improving the security and integrity of the data.
- title: Insecure Session Management - Password Change
  need: To ensure that an authenticated user session is invalidated after a password change, preventing any potential unauthorized access.
  context:
    - Java
    - All type of applications (Web MPA, Web SPA, API REST, API GraphQL, etc.)
    - javax.servlet and javax.servlet.http
  vulnerability_id: "295"
  solution:
    language: java
    insecure_code_example:
      text: |
        public void changePassword(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            User user = (User) request.getSession().getAttribute("user");
            String newPassword = request.getParameter("newPassword");

            user.setPassword(newPassword);
            // Update user in the database
            // ...

            // Session remains open after password change
        }
      description: In this insecure code example, the password of a user is changed but the user's session remains open. This can lead to a security vulnerability if the session has been compromised, as the attacker can still use the old session even after the password has been changed.
    steps:
      - Invalidate the current session after a successful password change.
      - Force the user to re-authenticate to create a new session.
    secure_code_example:
      text: |
        public void changePassword(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            User user = (User) request.getSession().getAttribute("user");
            String newPassword = request.getParameter("newPassword");

            user.setPassword(newPassword);
            // Update user in the database
            // ...

            // Invalidate the session after password change
            request.getSession().invalidate();

            // Redirect to login page
            response.sendRedirect("login");
        }
      description: In the secure code example, the user's session is invalidated after a successful password change and the user is redirected to the login page to re-authenticate and start a new session. This way, if an attacker has control over the old session, they would lose access after the password change.
- title: Authentication Evasion via Redirection
  need: To ensure that application access is granted only after a strong authentication process, and a valid user is verified.
  context:
    - Java
    - All type of applications (Web MPA, Web SPA, API REST, API GraphQL, etc.)
    - javax.servlet and javax.servlet.http
  vulnerability_id: "298"
  solution:
    language: java
    insecure_code_example:
      text: |
        public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            String username = request.getParameter("username");
            String password = request.getParameter("password");

            if (username != null && password != null && username.equals("admin")) {
                // Redirects to admin page even without checking password
                response.sendRedirect("/admin");
            } else {
                response.sendRedirect("/login");
            }
        }
      description: In this insecure code example, the application redirects the user to the admin page if the username is "admin", without checking if the password is correct. This allows an attacker to access the admin page by simply knowing a valid username and manipulating the redirection process.
    steps:
      - Implement a secure authentication mechanism that verifies both the username and password before granting access.
      - Use server-side session management to track authenticated users.
    secure_code_example:
      text: |
        public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            String username = request.getParameter("username");
            String password = request.getParameter("password");

            // Authenticates the user
            boolean isAuthenticated = authenticateUser(username, password);

            if (isAuthenticated) {
                // Only redirect to admin page after successful authentication
                response.sendRedirect("/admin");
            } else {
                response.sendRedirect("/login");
            }
        }

        private boolean authenticateUser(String username, String password) {
            // Implement secure user authentication (e.g., check username and password against a database)
            // Return true if user is authenticated, false otherwise
        }
      description: In the secure code example, the application only redirects the user to the admin page after a successful authentication process that verifies both the username and password. This helps prevent an attacker from gaining access to the application by bypassing the authentication process and manipulating the redirection process.
- title: Concurrent Sessions Control Bypass
  need: To prevent multiple active sessions for the same user, ensuring better security and traceability.
  context:
    - Java
    - All type of applications (Web MPA, Web SPA, API REST, API GraphQL, etc.)
    - javax.servlet and javax.servlet.http
  vulnerability_id: "301"
  solution:
    language: java
    insecure_code_example:
      text: |
        public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            String username = request.getParameter("username");
            String password = request.getParameter("password");

            if (username != null && password != null && authenticateUser(username, password)) {
                // User is authenticated, but no check for existing sessions
                HttpSession session = request.getSession();
                session.setAttribute("username", username);
                response.sendRedirect("/home");
            } else {
                response.sendRedirect("/login");
            }
        }

        private boolean authenticateUser(String username, String password) {
            // Implement user authentication (e.g., check username and password against a database)
            // Return true if user is authenticated, false otherwise
        }
      description: The insecure code doesn't check for existing sessions before creating a new one, allowing multiple concurrent sessions for the same user. This could allow an attacker to bypass the concurrent session control by creating multiple sessions, leading to a loss of traceability.
    steps:
      - Before creating a new session, check if an active session exists for the user.
      - If an active session exists, invalidate it before creating a new one.
      - Ensure to handle all application requests through the established session management system.
    secure_code_example:
      text: |
        public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            String username = request.getParameter("username");
            String password = request.getParameter("password");

            if (username != null && password != null && authenticateUser(username, password)) {
                HttpSession oldSession = request.getSession(false);
                if (oldSession != null) {
                    oldSession.invalidate();
                }

                // Create a new session for the authenticated user
                HttpSession newSession = request.getSession(true);
                newSession.setAttribute("username", username);
                response.sendRedirect("/home");
            } else {
                response.sendRedirect("/login");
            }
        }

        private boolean authenticateUser(String username, String password) {
            // Implement user authentication (e.g., check username and password against a database)
            // Return true if user is authenticated, false otherwise
        }
      description: The secure code first checks if an active session exists for the user before creating a new one. If an active session exists, it's invalidated before a new one is created. This prevents multiple concurrent sessions for the same user, ensuring better security and traceability.
- title: Insecure Functionality - Session Management
  need: To ensure session tokens, once expired, cannot be reused, preserving the security of the application and its data.
  context:
    - Java
    - All types of applications (Web MPA, Web SPA, API REST, API GraphQL, etc.)
    - javax.servlet, javax.servlet.http, java.util.Date, and io.jsonwebtoken.*
  vulnerability_id: "302"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import io.jsonwebtoken.Jwts;
        import io.jsonwebtoken.Claims;
        import java.util.Date;

        public void doRequest(HttpServletRequest request) {
            String token = request.getHeader("Authorization");
            if (token != null) {
                Claims claims = Jwts.parser().setSigningKey("secret").parseClaimsJws(token).getBody();

                // Vulnerable part, the code allows expired tokens to be refreshed
                if (claims.getExpiration().before(new Date())) {
                    claims.setExpiration(new Date(System.currentTimeMillis() + 3600000)); // 1 hour
                }

                // Process the request...
            }
        }
      description: The insecure code allows expired tokens to be refreshed. This would allow an attacker to reuse an expired token, which would make it functional again, thus breaching the security of the application.
    steps:
      - Do not allow expired tokens to be refreshed.
      - If a token has expired, prompt the user to re-authenticate.
      - Validate tokens server-side and reject any requests with expired tokens.
    secure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import io.jsonwebtoken.Jwts;
        import io.jsonwebtoken.Claims;
        import io.jsonwebtoken.ExpiredJwtException;
        import java.util.Date;

        public void doRequest(HttpServletRequest request) {
            String token = request.getHeader("Authorization");
            if (token != null) {
                try {
                    Claims claims = Jwts.parser().setSigningKey("secret").parseClaimsJws(token).getBody();
                    // Process the request...
                } catch (ExpiredJwtException e) {
                    // Token has expired, prompt the user to re-authenticate.
                }
            }
        }
      description: The secure code validates tokens server-side and rejects any requests with expired tokens. This ensures that once session tokens have expired, they cannot be reused in future requests, improving the security of the application.
- title: Security Controls Bypass or Absence - Data Creation
  need: To enforce the rule that a maximum of four beneficiaries can be associated with a policy, thus maintaining the integrity of the data.
  context:
    - Java
    - All types of applications (Web MPA, Web SPA, API REST, API GraphQL, etc.)
    - javax.servlet, javax.servlet.http, and java.util.List
  vulnerability_id: "305"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import java.util.List;

        public void createPolicy(HttpServletRequest request) {
            String policyHolder = request.getParameter("policyHolder");
            List<String> beneficiaries = request.getParameterValues("beneficiaries");

            // Create policy with all beneficiaries, no limit check
            Policy policy = new Policy(policyHolder, beneficiaries);
            policyService.createPolicy(policy);
        }
      description: The insecure code allows an attacker to associate more than four beneficiaries to a policy by bypassing the client-side restriction. This can lead to data integrity issues as the application's backend is not prepared to handle more than four beneficiaries for a policy.
    steps:
      - Enforce the maximum limit of beneficiaries on the server side.
      - Return an error response when the limit is exceeded.
      - Reject the request if the number of beneficiaries exceeds the limit.
    secure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import java.util.List;

        public void createPolicy(HttpServletRequest request) {
            String policyHolder = request.getParameter("policyHolder");
            List<String> beneficiaries = request.getParameterValues("beneficiaries");

            // Check if the number of beneficiaries exceeds the limit
            if (beneficiaries.size() > 4) {
                throw new IllegalArgumentException("The number of beneficiaries cannot exceed 4");
            }

            // Create policy with all beneficiaries, with limit check
            Policy policy = new Policy(policyHolder, beneficiaries);
            policyService.createPolicy(policy);
        }
      description: The secure code checks the number of beneficiaries on the server side and throws an exception when the limit is exceeded. This prevents the association of more than four beneficiaries to a policy, ensuring the integrity of the data.
- title: Insecure Direct Object References - Files
  need: To prevent unauthorized access and manipulation of user data by validating user permissions
  context:
    - Java
    - All types of applications (Web MPA, Web SPA, API REST, API GraphQL, etc.)
    - javax.servlet, javax.servlet.http
  vulnerability_id: "306"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;

        public void getUserFile(HttpServletRequest request) {
            String userId = request.getParameter("userId");
            String fileName = request.getParameter("fileName");

            // Fetch file without checking if user has access to it
            File file = fileService.getUserFile(userId, fileName);
            // Send file to client
        }
      description: This insecure code fetches and sends the file based on the provided user ID and file name, without checking if the user making the request has the necessary permissions to access the file. An attacker can easily manipulate the user ID to access or manipulate files of other users.
    steps:
      - Check if the user making the request is authorized to access the file before fetching and sending the file.
      - Implement an authorization system that maps user IDs to permissions.
      - Only allow access to the file if the user has the necessary permissions.
    secure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpSession;

        public void getUserFile(HttpServletRequest request) {
            HttpSession session = request.getSession();
            String userId = (String) session.getAttribute("userId"); // Get user id from session
            String requestUserId = request.getParameter("userId");
            String fileName = request.getParameter("fileName");

            // Check if user is authorized to access the file
            if (!userId.equals(requestUserId)) {
                throw new SecurityException("Unauthorized file access attempt");
            }

            // Fetch file
            File file = fileService.getUserFile(userId, fileName);
            // Send file to client
        }
      description: The secure code checks if the user making the request is authorized to access the file by comparing the user ID stored in the session with the user ID provided in the request. If the IDs do not match, it throws a security exception, preventing unauthorized access to the file.
- title: Insecure Direct Object References - Data
  need: To prevent unauthorized access and manipulation of store data by validating user permissions
  context:
    - Java
    - All types of applications (Web MPA, Web SPA, API REST, API GraphQL, etc.)
    - javax.servlet, javax.servlet.http
  vulnerability_id: "307"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;

        public void getStoreData(HttpServletRequest request) {
            String storeId = request.getParameter("storeId");

            // Fetch store data without checking if user has access to it
            StoreData storeData = storeDataService.getStoreData(storeId);
            // Send data to client
        }
      description: This insecure code fetches and sends the store data based on the provided store ID, without checking if the user making the request has the necessary permissions to access the store data. An attacker can easily manipulate the store ID to access or manipulate data of other stores.
    steps:
      - Check if the user making the request is authorized to access the store data before fetching and sending it.
      - Implement an authorization system that maps user IDs to store IDs and permissions.
      - Only allow access to the store data if the user has the necessary permissions.
    secure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpSession;

        public void getStoreData(HttpServletRequest request) {
            HttpSession session = request.getSession();
            String userId = (String) session.getAttribute("userId"); // Get user id from session
            String requestStoreId = request.getParameter("storeId");

            // Check if user is authorized to access the store data
            if (!storeDataService.userHasAccessToStore(userId, requestStoreId)) {
                throw new SecurityException("Unauthorized store data access attempt");
            }

            // Fetch store data
            StoreData storeData = storeDataService.getStoreData(requestStoreId);
            // Send data to client
        }
      description: The secure code checks if the user making the request is authorized to access the store data by verifying the user's permissions in the store data service. If the user does not have the necessary permissions, it throws a security exception, preventing unauthorized access to the store data.
- title: Insecure Token Generation - JWT
  need: To ensure tokens are generated securely with strong signing keys
  context:
    - Java
    - All types of applications (Web MPA, Web SPA, API REST, API GraphQL, etc.)
    - javax.servlet, javax.servlet.http, io.jsonwebtoken
  vulnerability_id: "309"
  solution:
    language: java
    insecure_code_example:
      text: |
        import io.jsonwebtoken.Jwts;
        import io.jsonwebtoken.SignatureAlgorithm;
        import javax.servlet.http.HttpServletRequest;
        import java.util.Date;

        public String generateToken(HttpServletRequest request) {
            String subject = request.getParameter("username");

            // Insecurely generated JWT token
            String token = Jwts.builder()
                .setSubject(subject)
                .setExpiration(new Date(System.currentTimeMillis() + 60 * 60 * 1000)) // 1 hour
                .signWith(SignatureAlgorithm.HS256, "secret") // weak secret key
                .compact();

            return token;
        }
      description: This insecure code generates a JWT token with a weak secret key, which can easily be guessed or brute-forced by an attacker. An attacker can then generate their own tokens or manipulate existing ones, such as changing the expiration date.
    steps:
      - Use a strong secret key for the token signing.
      - Store the secret key securely, not in plaintext in the source code.
      - Consider using a library or service that specializes in securely generating and managing JWTs.
    secure_code_example:
      text: |
        import io.jsonwebtoken.Jwts;
        import io.jsonwebtoken.SignatureAlgorithm;
        import javax.servlet.http.HttpServletRequest;
        import java.util.Date;

        public String generateToken(HttpServletRequest request) {
            String subject = request.getParameter("username");

            // Securely generated JWT token
            String token = Jwts.builder()
                .setSubject(subject)
                .setExpiration(new Date(System.currentTimeMillis() + 60 * 60 * 1000)) // 1 hour
                .signWith(SignatureAlgorithm.HS256, getSecretKey()) // strong secret key
                .compact();

            return token;
        }

        private String getSecretKey() {
            // Fetch securely stored secret key
            return System.getenv("JWT_SECRET_KEY");
        }
      description: The secure code fetches the secret key from a secure location (like an environment variable) rather than having it in plaintext in the source code. This makes it much harder for an attacker to guess or brute-force the secret key.
- title: Inefficient String Concatenation in Loop - Buffer Overflow
  need: To ensure efficient memory usage and prevent performance issues
  context:
    - Java
    - All types of applications (Web MPA, Web SPA, API REST, API GraphQL, etc.)
    - javax.servlet, javax.servlet.http
  vulnerability_id: "316"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import java.util.List;

        public String concatenateStrings(List<String> strings) {
            String result = "";

            for (String str : strings) {
                result += str; // inefficient concatenation in loop
            }

            return result;
        }
      description: The insecure code inefficiently concatenates Strings inside a loop. Each concatenation creates a new String object, which can lead to performance issues for large lists due to the constant allocation and deallocation of memory.
    steps:
      - Use StringBuilder or StringBuffer for concatenating Strings in a loop.
      - StringBuilder is faster but not thread-safe, while StringBuffer is slower but thread-safe. Choose the appropriate one based on your needs.
    secure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import java.util.List;

        public String concatenateStrings(List<String> strings) {
            StringBuilder result = new StringBuilder();

            for (String str : strings) {
                result.append(str); // efficient concatenation in loop
            }

            return result.toString();
        }
      description: The secure code uses a StringBuilder to efficiently concatenate Strings inside a loop. This avoids the performance issues caused by the constant allocation and deallocation of memory in the insecure code.
- title: Unmanaged Resource Allocation - Memory Leak
  need: To prevent exhaustion of system resources and degradation of application performance
  context:
    - Java
    - All types of applications (Web MPA, Web SPA, API REST, API GraphQL, etc.)
    - javax.servlet, javax.servlet.http, java.io
  vulnerability_id: "317"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import java.io.*;

        public void readData(HttpServletRequest request) {
            try {
                InputStream in = request.getInputStream();
                byte[] data = new byte[1024];
                while (in.read(data) != -1) {
                    // Processing data...
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
      description: The insecure code reads data from the request input stream but does not close the stream afterwards. This can lead to a memory leak as system resources allocated to the stream are not released, potentially causing the system to run out of resources.
    steps:
      - Always close streams after use.
      - Use the try-with-resources construct to automatically close resources after use.
    secure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import java.io.*;

        public void readData(HttpServletRequest request) {
            try (InputStream in = request.getInputStream()) {
                byte[] data = new byte[1024];
                while (in.read(data) != -1) {
                    // Processing data...
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
      description: The secure code uses the try-with-resources construct to ensure that the input stream is closed after use. This prevents the memory leak by ensuring that system resources allocated to the stream are released.
- title: Insecure Token Validation
  need: To ensure authenticity and integrity of user actions
  context:
    - Java
    - All types of applications (Web MPA, Web SPA, API REST, API GraphQL, etc.)
    - javax.servlet, javax.servlet.http, java.io, io.jsonwebtoken
  vulnerability_id: "318"
  solution:
    language: java
    insecure_code_example:
      text: |
        import io.jsonwebtoken.Jwts;
        import javax.servlet.http.HttpServletRequest;
        import java.io.*;

        public void createUser(HttpServletRequest request) {
            try {
                String token = request.getHeader("Authorization").split(" ")[1];
                String key = "weakKey";
                Jwts.parser().setSigningKey(key).parseClaimsJws(token);
                // Create user...
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
      description: The insecure code validates the JWT token by using the algorithm found in the token header. An attacker could modify this header to manipulate the validation process and potentially create users with tokens that are not correctly signed.
    steps:
      - Do not rely on the token header for the signing algorithm.
      - Specify the signing algorithm explicitly when validating the token.
      - Use a strong key for signing and verification of tokens.
    secure_code_example:
      text: |
        import io.jsonwebtoken.*;
        import javax.servlet.http.HttpServletRequest;
        import java.io.*;

        public void createUser(HttpServletRequest request) {
            try {
                String token = request.getHeader("Authorization").split(" ")[1];
                String key = "strongKey";
                Jwts.parser().setSigningKey(key).parseClaimsJws(token).getBody();
                // Create user...
            } catch (SignatureException e) {
                // log token signature exception
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
      description: The secure code specifies the signing algorithm explicitly when validating the token and uses a strong key for signing and verification. This ensures that even if an attacker modifies the token header, the token validation will not be affected, preventing the creation of users with tokens that are not correctly signed.
- title: Insecure Token Lifespan
  need: To limit the window of opportunity for an attacker to use a stolen session token
  context:
    - Java
    - All types of applications (Web MPA, Web SPA, API REST, API GraphQL, etc.)
    - javax.servlet, javax.servlet.http, java.io, io.jsonwebtoken
  vulnerability_id: "322"
  solution:
    language: java
    insecure_code_example:
      text: |
        import io.jsonwebtoken.Jwts;
        import io.jsonwebtoken.SignatureAlgorithm;
        import javax.servlet.http.HttpServletResponse;
        import java.util.Date;

        public void createToken(HttpServletResponse response) {
            try {
                String key = "weakKey";
                long nowMillis = System.currentTimeMillis();
                long expMillis = nowMillis + (1000 * 60 * 60 * 24 * 5); // 5 days
                Date exp = new Date(expMillis);
                String jwt = Jwts.builder().setIssuedAt(new Date()).setExpiration(exp)
                        .signWith(SignatureAlgorithm.HS256, key).compact();
                response.setHeader("Authorization", "Bearer " + jwt);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
      description: The insecure code generates a JWT token with a lifespan of approximately 5 days. This provides an extended period for an attacker to leverage a stolen session token.
    steps:
      - Decrease the lifespan of tokens to limit the window of opportunity for an attacker.
      - Consider other factors such as user behavior and sensitivity of data when deciding token lifespan.
    secure_code_example:
      text: |
        import io.jsonwebtoken.Jwts;
        import io.jsonwebtoken.SignatureAlgorithm;
        import javax.servlet.http.HttpServletResponse;
        import java.util.Date;

        public void createToken(HttpServletResponse response) {
            try {
                String key = "strongKey";
                long nowMillis = System.currentTimeMillis();
                long expMillis = nowMillis + (1000 * 60 * 60); // 1 hour
                Date exp = new Date(expMillis);
                String jwt = Jwts.builder().setIssuedAt(new Date()).setExpiration(exp)
                        .signWith(SignatureAlgorithm.HS256, key).compact();
                response.setHeader("Authorization", "Bearer " + jwt);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
      description: The secure code generates a JWT token with a much shorter lifespan of approximately 1 hour. This limits the window of opportunity for an attacker to use a stolen session token.
- title: Insecure User Management
  need: To prevent unauthorized users from gaining access to sensitive information or capabilities
  context:
    - Java
    - All types of applications (Web MPA, Web SPA, API REST, API GraphQL, etc.)
    - javax.servlet, javax.servlet.http, java.io
  vulnerability_id: "324"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletResponse;

        public void manageUser(HttpServletRequest request, HttpServletResponse response) {
            try {
                String email = request.getParameter("email");
                String project = request.getParameter("project");
                // The user is assigned as manager without checking if they are registered in the system
                assignAsManager(email, project);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        private void assignAsManager(String email, String project) {
            // Logic to assign the user as manager
        }
      description: The insecure code assigns a user as a manager without checking if they are registered in the system. This can lead to unauthorized access and disclosure of sensitive information.
    steps:
      - Implement checks to verify that the user is registered in the system before assigning them as a manager.
      - Implement additional controls to verify that a user has the necessary permissions to access information or perform actions.
    secure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletResponse;

        public void manageUser(HttpServletRequest request, HttpServletResponse response) {
            try {
                String email = request.getParameter("email");
                String project = request.getParameter("project");
                if(isUserRegistered(email)){
                    assignAsManager(email, project);
                }else{
                    // Inform the requester about the unregistered user
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        private boolean isUserRegistered(String email) {
            // Logic to check if the user is registered in the system
            return true;
        }

        private void assignAsManager(String email, String project) {
            // Logic to assign the user as manager
        }
      description: The secure code first verifies that the user is registered in the system before assigning them as a manager. This prevents unauthorized access and disclosure of sensitive information.
- title: Insecure Session Management
  need: To prevent unauthorized session termination for users
  context:
    - Java
    - All types of applications (Web MPA, Web SPA, API REST, API GraphQL, etc.)
    - javax.servlet, javax.servlet.http, java.io
  vulnerability_id: "328"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletResponse;
        import java.util.HashMap;

        HashMap<String, String> sessions = new HashMap<>();

        public void logoutUser(HttpServletRequest request, HttpServletResponse response) {
            try {
                String email = request.getParameter("email");
                sessions.remove(email);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
      description: The insecure code allows any user to terminate the sessions of other users by knowing their e-mail. It takes the email parameter from the request and removes the corresponding session without any validation.
    steps:
      - Implement checks to verify that the user attempting to terminate the session is the owner of the session.
      - Use session IDs to manage sessions instead of user emails. Session IDs should be securely stored and handled.
    secure_code_example:
      text: |
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletResponse;
        import java.util.HashMap;

        HashMap<String, String> sessions = new HashMap<>();

        public void logoutUser(HttpServletRequest request, HttpServletResponse response) {
            try {
                String sessionID = request.getSession().getId();
                if(sessions.containsValue(sessionID)){
                    sessions.values().remove(sessionID);
                }else{
                    // Inform the requester about the invalid session ID
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
      description: The secure code checks if the session ID provided in the request is valid and belongs to the user attempting to terminate the session. This prevents unauthorized session termination.
- title: Unspecified Content-Type Header
  need: To prevent potential security risks due to content misinterpretation
  context:
    - Java
    - All types of applications (Web MPA, Web SPA, API REST, API GraphQL, etc.)
    - javax.servlet, javax.servlet.http
  vulnerability_id: "329"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.http.HttpServletResponse;
        import java.io.IOException;

        public void sendResponse(HttpServletResponse response, String data) {
            try {
                response.getWriter().write(data);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
      description: The insecure code sends a response to the client without explicitly setting the Content-Type header. This may lead to unexpected behaviors and security vulnerabilities because the client might misinterpret the content.
    steps:
      - Always set the Content-Type header in the server response.
      - The Content-Type should be appropriate for the data being sent.
    secure_code_example:
      text: |
        import javax.servlet.http.HttpServletResponse;
        import java.io.IOException;

        public void sendResponse(HttpServletResponse response, String data) {
            try {
                response.setContentType("text/html;charset=UTF-8");
                response.getWriter().write(data);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
      description: The secure code always sets the Content-Type header to "text/html;charset=UTF-8" before sending the response. This prevents potential security risks due to content misinterpretation.
- title: CSRF Token Fixation
  need: To ensure authenticity of user requests and prevent CSRF attacks
  context:
    - Java
    - All types of applications (Web MPA, Web SPA, API REST, API GraphQL, etc.)
    - javax.servlet, javax.servlet.http
  vulnerability_id: "337"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.http.HttpServlet;
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletResponse;
        import java.io.IOException;

        public class TransactionServlet extends HttpServlet {
            protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {
                String amount = request.getParameter("amount");
                String toAccount = request.getParameter("toAccount");

                // Process the transaction...
            }
        }
      description: This vulnerable code does not check for CSRF tokens in incoming requests, making it possible for an attacker to initiate transactions by tricking an authenticated user into submitting a request.
    steps:
      - Include CSRF tokens in your forms.
      - Verify the CSRF token in server-side before processing the request.
      - Rotate CSRF tokens after each request.
    secure_code_example:
      text: |
        import javax.servlet.http.HttpServlet;
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletResponse;
        import java.io.IOException;

        public class TransactionServlet extends HttpServlet {
            protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {
                String amount = request.getParameter("amount");
                String toAccount = request.getParameter("toAccount");
                String csrfToken = request.getParameter("csrfToken");

                if (isValidCsrfToken(csrfToken)) {
                    // Process the transaction...
                } else {
                    response.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid CSRF token");
                }
            }

            private boolean isValidCsrfToken(String csrfToken) {
                // Validate CSRF token...
                return true;
            }
        }
      description: The secure code verifies the CSRF token for every transaction request. This helps to ensure that the request is made by a legitimate user, not by a CSRF attacker.
- title: Insecure Salt Generation
  need: To ensure password security against dictionary attacks
  context:
    - Java
    - All types of applications (Web MPA, Web SPA, API REST, API GraphQL, etc.)
    - java.security.SecureRandom
  vulnerability_id: "338"
  solution:
    language: java
    insecure_code_example:
      text: |
        import java.util.Random;

        public class SaltGenerator {
            public static String generateSalt() {
                Random random = new Random();
                byte[] salt = new byte[16];
                random.nextBytes(salt);
                return new String(salt);
            }
        }
      description: This code generates a salt for password hashing using java.util.Random, which is not cryptographically secure and can make the hashed password easier to crack.
    steps:
      - Use a secure random number generator to create the salt.
      - Use the generated salt along with the password to create a hash.
      - Store the salt and hash in your user database.
    secure_code_example:
      text: |
        import java.security.SecureRandom;

        public class SaltGenerator {
            public static byte[] generateSalt() {
                SecureRandom random = new SecureRandom();
                byte[] salt = new byte[16];
                random.nextBytes(salt);
                return salt;
            }
        }
      description: The secure code uses java.security.SecureRandom for generating the salt, which is a secure random number generator. This makes the salt hard to predict and the hashed password more resistant to dictionary attacks.
- title: Debugging Code Bypassing Security Control
  need: To prevent unauthorized access to the application
  context:
    - Java
    - All types of applications (Web MPA, Web SPA, API REST, API GraphQL, etc.)
    - javax.servlet.http.HttpSession
  vulnerability_id: "345"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.http.HttpSession;

        public class SessionManager {
            public static String getEmailFromSession(HttpSession session) {
                String sessionCode = (String) session.getAttribute("sessionCode");

                // Debugging code left in production
                if (sessionCode.contains("auto")) {
                    return "test@example.com";  // Returns the test user email
                }

                // Original logic for getting the email from the session
                return (String) session.getAttribute("email");
            }
        }
      description: This code has a debugging condition that checks if the session code contains the word "auto". If it does, the email of a test user is returned, allowing access to the application without having proper credentials.
    steps:
      - Remove debugging code from production code.
      - Always perform thorough reviews of code changes before deployment to catch such issues.
      - Include a checklist in the code review process to search for known risky code patterns, like hard-coded credentials, testing/debugging code, etc.
    secure_code_example:
      text: |
        import javax.servlet.http.HttpSession;

        public class SessionManager {
            public static String getEmailFromSession(HttpSession session) {
                // Only the original logic for getting the email from the session
                return (String) session.getAttribute("email");
            }
        }
      description: This revised code removes the debugging condition, ensuring that only the original logic for retrieving the email from the session is used. This prevents unauthorized access to the application.
- title: Insecure TrustManager Implementation
  need: To prevent Man-in-the-Middle (MITM) attacks by properly validating server certificates
  context:
    - Java
    - All types of applications (Web MPA, Web SPA, API REST, API GraphQL, etc.)
    - javax.net.ssl.X509TrustManager
  vulnerability_id: "350"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.net.ssl.X509TrustManager;
        import java.security.cert.X509Certificate;

        public class InsecureTrustManager implements X509TrustManager {
            public void checkServerTrusted(X509Certificate[] chain, String authType) {
                // No exception is thrown when an invalid certificate is detected
            }

            public X509Certificate[] getAcceptedIssuers() {
                return new X509Certificate[0];
            }
        }
      description: This code represents an insecure implementation of the TrustManager. The `checkServerTrusted` method, which is responsible for validating server certificates, is empty and does not throw a certificate exception when an invalid certificate is detected. This allows any incoming certificate, potentially enabling MITM attacks.
    steps:
      - Implement proper logic in `checkServerTrusted` method to validate server certificates.
      - Throw a CertificateException if a certificate is found to be invalid.
      - Log the details of the event for auditing purposes.
    secure_code_example:
      text: |
        import javax.net.ssl.X509TrustManager;
        import java.security.cert.CertificateException;
        import java.security.cert.X509Certificate;

        public class SecureTrustManager implements X509TrustManager {
            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
                for (X509Certificate cert : chain) {
                    // Check validity of each certificate in the chain
                    cert.checkValidity();
                }
            }

            public X509Certificate[] getAcceptedIssuers() {
                return new X509Certificate[0];
            }
        }
      description: This code includes the correct implementation of the TrustManager. The `checkServerTrusted` method now validates server certificates and throws a `CertificateException` when an invalid certificate is detected, preventing potential MITM attacks.
- title: Insecure Storage of Sensitive Environment Variables
  need: To protect sensitive information like passwords, tokens, usernames from exposure
  context:
    - Java
    - All types of applications (Web MPA, Web SPA, API REST, API GraphQL, etc.)
    - Git
  vulnerability_id: "352"
  solution:
    language: java
    insecure_code_example:
      text: |
        import java.util.Map;

        public class PrintEnv {
            public static void main(String[] args) {
                Map<String, String> env = System.getenv();
                for (String envName : env.keySet()) {
                    System.out.format("%s=%s%n", envName, env.get(envName));
                }
            }
        }
      description: This code gets all the environment variables and prints them without any masking or protection. If sensitive information such as passwords or tokens are stored in these variables, they can be exposed to unauthorized individuals.
    steps:
      - Never print environment variables in logs or console without masking sensitive ones.
      - Store sensitive data in a secure manner. Make use of secure vaults or encrypted storage for such data.
      - Validate the users and their permissions before granting access to sensitive data.
    secure_code_example:
      text: |
        import java.util.Map;

        public class PrintEnv {
            public static void main(String[] args) {
                Map<String, String> env = System.getenv();
                for (String envName : env.keySet()) {
                    if (isSensitive(envName)) {
                        System.out.format("%s=%s%n", envName, "*****");
                    } else {
                        System.out.format("%s=%s%n", envName, env.get(envName));
                    }
                }
            }

            private static boolean isSensitive(String envName) {
                // Logic to determine if the environment variable is sensitive
                return envName.contains("PASSWORD") || envName.contains("TOKEN");
            }
        }
      description: In this updated version of the code, sensitive environment variables (like those containing "PASSWORD" or "TOKEN" in the name) are masked when printed. This helps to protect them from accidental exposure in logs or console output.
- title: Insecure Storage of Sensitive Environment Variables
  need: To protect sensitive information like passwords, tokens, usernames from exposure
  context:
    - Java
    - All types of applications (Web MPA, Web SPA, API REST, API GraphQL, etc.)
    - Git
  vulnerability_id: "352"
  solution:
    language: java
    insecure_code_example:
      text: |
        import java.util.Map;

        public class PrintEnv {
            public static void main(String[] args) {
                Map<String, String> env = System.getenv();
                for (String envName : env.keySet()) {
                    System.out.format("%s=%s%n", envName, env.get(envName));
                }
            }
        }
      description: This code gets all the environment variables and prints them without any masking or protection. If sensitive information such as passwords or tokens are stored in these variables, they can be exposed to unauthorized individuals.
    steps:
      - Never print environment variables in logs or console without masking sensitive ones.
      - Store sensitive data in a secure manner. Make use of secure vaults or encrypted storage for such data.
      - Validate the users and their permissions before granting access to sensitive data.
    secure_code_example:
      text: |
        import java.util.Map;

        public class PrintEnv {
            public static void main(String[] args) {
                Map<String, String> env = System.getenv();
                for (String envName : env.keySet()) {
                    if (isSensitive(envName)) {
                        System.out.format("%s=%s%n", envName, "*****");
                    } else {
                        System.out.format("%s=%s%n", envName, env.get(envName));
                    }
                }
            }

            private static boolean isSensitive(String envName) {
                // Logic to determine if the environment variable is sensitive
                return envName.contains("PASSWORD") || envName.contains("TOKEN");
            }
        }
      description: In this updated version of the code, sensitive environment variables (like those containing "PASSWORD" or "TOKEN" in the name) are masked when printed. This helps to protect them from accidental exposure in logs or console output.
- title: Uncontrolled SMTP Requests
  need: To prevent the application from crashing due to uncontrolled SMTP requests
  context:
    - Java
    - Web MPA, Web SPA, API REST, API GraphQL
    - SMTP (JavaMail API)
  vulnerability_id: "356"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.http.*;
        import javax.servlet.*;
        import java.io.*;
        import javax.mail.*;
        import javax.mail.internet.*;

        public class EmailServlet extends HttpServlet {
            public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                String toEmail = request.getParameter("txtEmail");
                String subject = "Test Mail";
                String message = "This is a test mail";
                sendEmail(toEmail, subject, message);
            }

            private void sendEmail(String toEmail, String subject, String message) {
                // SMTP server properties and email sending logic
            }
        }
      description: This code receives an email address from a form post and sends an email to that address. The issue here is that there's no validation or limit on the size of the 'txtEmail' field, which can cause the application to crash due to uncontrolled SMTP requests.
    steps:
      - Validate the 'txtEmail' field to ensure it contains a properly formatted email address.
      - Implement a limit on the size of the 'txtEmail' field to prevent overloading the server.
    secure_code_example:
      text: |
        import javax.servlet.http.*;
        import javax.servlet.*;
        import java.io.*;
        import javax.mail.*;
        import javax.mail.internet.*;

        public class EmailServlet extends HttpServlet {
            private static final int MAX_EMAIL_SIZE = 255;

            public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                String toEmail = request.getParameter("txtEmail");
                if (isValidEmail(toEmail)) {
                    String subject = "Test Mail";
                    String message = "This is a test mail";
                    sendEmail(toEmail, subject, message);
                } else {
                    // Respond with an error
                }
            }

            private boolean isValidEmail(String email) {
                // Basic check to demonstrate validation
                return email != null && email.length() <= MAX_EMAIL_SIZE && email.contains("@");
            }

            private void sendEmail(String toEmail, String subject, String message) {
                // SMTP server properties and email sending logic
            }
        }
      description: This updated code includes validation of the 'txtEmail' field, ensuring that it is not null, does not exceed a maximum size, and contains an '@' symbol. By implementing these validations, we can prevent uncontrolled SMTP requests that could crash the application.
- title: Uncontrolled SFTP Requests
  need: To prevent the application from crashing due to uncontrolled SFTP requests
  context:
    - Java
    - Web MPA, Web SPA, API REST, API GraphQL
    - SFTP (JSch API)
  vulnerability_id: "357"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.http.*;
        import javax.servlet.*;
        import com.jcraft.jsch.*;

        public class SftpServlet extends HttpServlet {
            public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                String hostname = request.getParameter("hostname");
                String username = request.getParameter("username");
                String password = request.getParameter("password");

                JSch jsch = new JSch();
                Session session = jsch.getSession(username, hostname, 22);
                session.setPassword(password);
                session.connect();

                ChannelSftp channel = (ChannelSftp) session.openChannel("sftp");
                channel.connect();
                // Perform file operations
            }
        }
      description: This code opens an SFTP connection to a specified host and performs file operations. However, the issue here is that there's no timeout set for the connection or the file operations, which can lead to the server hanging if the operation takes too long.
    steps:
      - Set a timeout for the SFTP connection and file operations.
    secure_code_example:
      text: |
        import javax.servlet.http.*;
        import javax.servlet.*;
        import com.jcraft.jsch.*;

        public class SftpServlet extends HttpServlet {
            private static final int CONNECTION_TIMEOUT = 3000;
            private static final int CHANNEL_TIMEOUT = 3000;

            public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                String hostname = request.getParameter("hostname");
                String username = request.getParameter("username");
                String password = request.getParameter("password");

                JSch jsch = new JSch();
                Session session = jsch.getSession(username, hostname, 22);
                session.setPassword(password);
                session.setTimeout(CONNECTION_TIMEOUT);
                session.connect();

                ChannelSftp channel = (ChannelSftp) session.openChannel("sftp");
                channel.connect(CHANNEL_TIMEOUT);
                // Perform file operations
            }
        }
      description: This updated code includes a timeout for the SFTP connection and file operations. By implementing these timeouts, we can prevent the server from hanging when an operation takes too long and protect the application from potential denial of service attacks.
- title: Insecure Object Reference - User Deletion
  need: Protect system integrity by restricting deletion of users to authorized roles
  context:
    - Java 8 and above
    - Web applications using Java Servlets
  vulnerability_id: "369"
  solution:
    language: java
    insecure_code_example:
      text: |
        @WebServlet("/deleteUser")
        public class UserDeleteServlet extends HttpServlet {

          protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            String userId = request.getParameter("userId");
            UserDao userDao = new UserDao();
            userDao.deleteUser(userId);
          }
        }
      description: The above code takes a user ID from the request and deletes the user. There's no check for user roles or permissions before performing the deletion.
    steps:
      - Check the role of the current user before performing critical operations like user deletion.
      - Implement role-based access control.
      - If a user is deleted, invalidate their session immediately.
    secure_code_example:
      text: |
        @WebServlet("/deleteUser")
        public class UserDeleteServlet extends HttpServlet {

          protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            HttpSession session = request.getSession(false);
            User currentUser = (User) session.getAttribute("user");

            if (currentUser != null && currentUser.getRole().equals("ADMIN")) {
              String userId = request.getParameter("userId");
              UserDao userDao = new UserDao();
              userDao.deleteUser(userId);

              // If current user is the one being deleted, invalidate their session
              if (currentUser.getUserId().equals(userId)) {
                session.invalidate();
              }
            } else {
              response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Unauthorized user attempted to delete a user");
            }
          }
        }
      description: The updated code checks if the current user has an admin role before allowing user deletion. If the current user is the one being deleted, their session is invalidated immediately.
- title: Security Controls Bypass or Absence - Reversing Protection
  need: Prevent reverse-engineering of software to protect intellectual property and system integrity
  context:
    - Java 8 and above
    - All types of applications
  vulnerability_id: "376"
  solution:
    language: java
    insecure_code_example:
      text: |
        public class SecretKey {
            private static final String SECRET_KEY = "my-super-secret-key";

            public static String getSecretKey() {
                return SECRET_KEY;
            }
        }
      description: The above code stores a secret key as a string constant in the code. This is insecure because the key can easily be extracted by decompiling the class file.
    steps:
      - Avoid hardcoding sensitive information in your application code.
      - Use obfuscation tools to make your code harder to reverse-engineer.
      - Use secure storage mechanisms for sensitive data, such as environment variables or secure key vaults.
    secure_code_example:
      text: |
        public class SecretKey {
            private static final String SECRET_KEY = System.getenv("SECRET_KEY");

            public static String getSecretKey() {
                return SECRET_KEY;
            }
        }
      description: The updated code fetches the secret key from an environment variable, which is more secure than hardcoding it in the code. This prevents the key from being easily extracted via reverse-engineering.
- title: Cross-Site Leak - Frame Counting
  need: Prevent attackers from determining if a user is logged into the platform
  context:
    - Java 8 and above
    - Web applications (Web MPA, Web SPA, API REST, API GraphQL)
  vulnerability_id: "386"
  solution:
    language: java
    insecure_code_example:
      text: |
        // This is a pseudo code
        public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            if (request.getSession(false) == null) {
                response.getWriter().println("<iframe src='login.html'></iframe>");
            } else {
                response.getWriter().println("<iframe src='dashboard.html'></iframe>");
                response.getWriter().println("<iframe src='messages.html'></iframe>");
            }
        }
      description: The above code creates different number of iframes depending on whether the user is logged in or not. This can be exploited using a cross-site leak frame counting attack to determine if a user is logged in.
    steps:
      - Render the same number of frames regardless of whether the user is logged in or not.
      - Rely on the content within the frames to determine what the user sees, rather than the number of frames.
    secure_code_example:
      text: |
        // This is a pseudo code
        public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            if (request.getSession(false) == null) {
                response.getWriter().println("<iframe src='login.html'></iframe>");
                response.getWriter().println("<iframe style='display:none'></iframe>");
            } else {
                response.getWriter().println("<iframe src='dashboard.html'></iframe>");
                response.getWriter().println("<iframe src='messages.html'></iframe>");
            }
        }
      description: The updated code now always loads the same number of iframes, regardless of whether the user is logged in or not. This prevents a frame counting attack from being able to determine if a user is logged in.
- title: Insecure Service Configuration - Object Reutilization
  need: Prevent unauthorized reuse of one-time-use objects
  context:
    - Java 8 and above
    - Web applications (Web MPA, Web SPA, API REST, API GraphQL)
  vulnerability_id: "387"
  solution:
    language: java
    insecure_code_example:
      text: |
        // This is a pseudo code
        public class OneTimeUseToken {
            private String token;
            private boolean isUsed;

            public OneTimeUseToken(String token) {
                this.token = token;
                this.isUsed = false;
            }

            public String getToken() {
                return token;
            }
        }
      description: In this insecure example, the object representing a one-time-use token doesn't enforce the restriction that it should be used once. The token can be fetched multiple times, leading to object reuse vulnerability.
    steps:
      - Add a check to validate if the token has already been used.
      - If it has been used, either throw an exception or return a different response indicating that the token cannot be reused.
    secure_code_example:
      text: |
        // This is a pseudo code
        public class OneTimeUseToken {
            private String token;
            private boolean isUsed;

            public OneTimeUseToken(String token) {
                this.token = token;
                this.isUsed = false;
            }

            public String getToken() {
                if (isUsed) {
                    throw new IllegalStateException("Token has already been used.");
                }
                isUsed = true;
                return token;
            }
        }
      description: This secure version of the code now validates if the token has already been used. If it has been used, it throws an exception, preventing the token from being reused.
- title: Insecure Generation of Random Numbers - Static IV
  need: Ensuring the unpredictability of initialization vectors
  context:
    - Java 8 and above
    - Any type of application that uses encryption for secure data transmission or storage
  vulnerability_id: "395"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.crypto.spec.IvParameterSpec;

        public class InsecureApp {
            private static final String STATIC_IV = "1234567890123456"; // static, predictable initialization vector

            public IvParameterSpec generateIV() {
                return new IvParameterSpec(STATIC_IV.getBytes());
            }
        }
      description: This insecure example uses a static, hardcoded initialization vector (IV). If an attacker learns this IV, they can potentially predict the output of the encryption, leading to a security vulnerability.
    steps:
      - Use a secure random number generator to generate the initialization vector.
      - Ensure that a new initialization vector is generated for each encryption operation to maintain the unpredictability.
    secure_code_example:
      text: |
        import javax.crypto.spec.IvParameterSpec;
        import java.security.SecureRandom;

        public class SecureApp {
            private static final int IV_SIZE = 16;

            public IvParameterSpec generateIV() {
                SecureRandom secureRandom = new SecureRandom();
                byte[] iv = new byte[IV_SIZE];
                secureRandom.nextBytes(iv);
                return new IvParameterSpec(iv);
            }
        }
      description: In this secure version of the code, a new IV is randomly generated for each encryption operation, using a secure random number generator. This ensures that the IV is unpredictable and different for each encryption operation, mitigating the vulnerability.
- title: OS Command Injection
  need: Ensure command execution is safe and inputs are validated
  context:
    - Java 8 and above
    - Web MPA, Web SPA, API REST
    - Java Servlets for handling HTTP requests
  vulnerability_id: "404"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.*;
        import javax.servlet.http.*;
        import java.io.*;

        public class InsecureServlet extends HttpServlet {
            protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                String userInput = request.getParameter("dir");
                ProcessBuilder processBuilder = new ProcessBuilder("ls", "-l", userInput);
                Process process = processBuilder.start();
                // Further code...
            }
        }
      description: The above code is vulnerable because it uses the input from the user directly in a system command without any validation. If the user input contains malicious command, it can lead to command injection attack.
    steps:
      - Avoid executing system commands whenever possible.
      - If it is necessary to execute a system command, never use unsanitized user input as part of the command.
      - Validate all user inputs using regular expressions or whitelist validation before passing them to the system command.
    secure_code_example:
      text: |
        import javax.servlet.*;
        import javax.servlet.http.*;
        import java.io.*;
        import java.nio.file.*;

        public class SecureServlet extends HttpServlet {
            protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                String userInput = request.getParameter("dir");
                if(isSafe(userInput)) {
                    ProcessBuilder processBuilder = new ProcessBuilder("ls", "-l", userInput);
                    Process process = processBuilder.start();
                    // Further code...
                } else {
                    response.getWriter().println("Invalid directory.");
                }
            }

            private boolean isSafe(String userInput) {
                // Ensure the user input only contains alphanumeric characters
                return userInput.matches("^[a-zA-Z0-9]*$");
            }
        }
      description: This code is safe as it validates the user input using a whitelist of alphanumeric characters before passing it to the system command. If the input doesn't match the whitelist, it rejects the input and prevents the command injection.
- title: Insecure Service Configuration - Header Checking
  need: Ensure headers are safe from injection attacks
  context:
    - Java 8 and above
    - Web MPA, Web SPA, API REST
    - Java Servlets for handling HTTP requests
  vulnerability_id: "414"
  solution:
    language: java
    insecure_code_example:
      text: |
        import javax.servlet.*;
        import javax.servlet.http.*;

        public class InsecureServlet extends HttpServlet {
            protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                // Allow potentially unsafe characters in headers
                response.setHeader("X-Safe", "False");
                // Further code...
            }
        }
      description: The above code is vulnerable because it sets the response header "X-Safe" to "False". This implies that header checking, which prevents newline and carriage return characters in headers and protects against HTTP response splitting attacks, is not active.
    steps:
      - Avoid setting headers that disable safety checks in HTTP responses.
      - If it's necessary to customize headers, ensure that they don't disable important security checks.
    secure_code_example:
      text: |
        import javax.servlet.*;
        import javax.servlet.http.*;

        public class SecureServlet extends HttpServlet {
            protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                // Do not disable header checking
                response.setHeader("X-Safe", "True");
                // Further code...
            }
        }
      description: This code is safe as it doesn't disable the header checking. It sets the "X-Safe" header to "True", indicating that header checking is enabled and potentially unsafe characters in headers are blocked.
- title: Insecure Service Configuration - Container Level Access Policy
  need: Ensure granular control over permissions using container-level access policy
  context:
    - Java 8 and above
    - Web MPA, Web SPA, API REST
    - Microsoft Azure Storage SDK for Java
  vulnerability_id: "415"
  solution:
    language: java
    insecure_code_example:
      text: |
        import com.microsoft.azure.storage.*;
        import com.microsoft.azure.storage.blob.*;

        public class InsecureStorageConfiguration {
            public static void main(String[] args) {
                try {
                    CloudStorageAccount storageAccount = CloudStorageAccount.parse("connection string");
                    CloudBlobClient blobClient = storageAccount.createCloudBlobClient();
                    CloudBlobContainer container = blobClient.getContainerReference("container name");

                    // Define the permission to use for the SAS
                    BlobContainerPermissions permissions = new BlobContainerPermissions();
                    permissions.setPublicAccess(BlobContainerPublicAccessType.CONTAINER);

                    SharedAccessBlobPolicy sasPolicy = new SharedAccessBlobPolicy();
                    // Further code...
                } catch (Exception e) {
                    // Handle exception
                }
            }
        }
      description: The above code is vulnerable as it defines the permissions for the SAS at a granular level without associating it with a stored access policy. This reduces the control and flexibility over the granted permissions.
    steps:
      - Use a stored access policy to manage permissions for SAS.
      - Avoid setting permissions directly on the SAS; instead, specify a valid identifier for a stored access policy when generating the SAS.
    secure_code_example:
      text: |
        import com.microsoft.azure.storage.*;
        import com.microsoft.azure.storage.blob.*;

        public class SecureStorageConfiguration {
            public static void main(String[] args) {
                try {
                    CloudStorageAccount storageAccount = CloudStorageAccount.parse("connection string");
                    CloudBlobClient blobClient = storageAccount.createCloudBlobClient();
                    CloudBlobContainer container = blobClient.getContainerReference("container name");

                    // Create a new stored access policy
                    SharedAccessBlobPolicy storedPolicy = new SharedAccessBlobPolicy();
                    // Define the policy parameters
                    // ...

                    // Define a new container-level access policy
                    BlobContainerPermissions permissions = new BlobContainerPermissions();
                    permissions.setPublicAccess(BlobContainerPublicAccessType.CONTAINER);
                    permissions.getSharedAccessPolicies().put("policy name", storedPolicy);

                    // Set the container's permissions
                    container.uploadPermissions(permissions);

                    // Generate the SAS using the stored access policy
                    String sasToken = container.generateSharedAccessSignature(storedPolicy, null);
                    // Further code...
                } catch (Exception e) {
                    // Handle exception
                }
            }
        }
      description: This code securely sets up a container-level access policy, allowing greater control over the permissions granted by the SAS. It uses a stored access policy when generating the SAS, which can be modified or revoked as needed.
- title: Account Takeover Vulnerability
  need: Ensure secure account management by preventing unauthorized access
  context:
    - Java SE 8+
    - Web applications (Web MPA, Web SPA, API REST, etc.)
    - Java servlets used in the code
  vulnerability_id: "417"
  solution:
    language: java
    insecure_code_example:
      text: |
        @WebServlet("/passwordReset")
        public class PasswordResetServlet extends HttpServlet {
          protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            String username = request.getParameter("username");
            String newPassword = request.getParameter("newPassword");
            User user = Database.findUserByUsername(username);
            user.setPassword(newPassword);
            Database.updateUser(user);
          }
        }
      description: The servlet allows anyone to reset the password of any user, just by knowing their username. An attacker could exploit this to take over a user's account.
    steps:
      - Always validate the identity of the user when sensitive operations, like password resets, are requested. This can be done using security questions, email validation, or even two-factor authentication.
      - Avoid providing direct feedback indicating the existence of a user in the system.
    secure_code_example:
      text: |
        @WebServlet("/passwordReset")
        public class PasswordResetServlet extends HttpServlet {
          protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            String username = request.getParameter("username");
            String newPassword = request.getParameter("newPassword");
            String securityAnswer = request.getParameter("securityAnswer");

            User user = Database.findUserByUsername(username);
            if (user != null && user.getSecurityAnswer().equals(securityAnswer)) {
              user.setPassword(newPassword);
              Database.updateUser(user);
            }
            else {
              response.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid security answer.");
            }
          }
        }
      description: The updated code now requires a correct answer to a security question before a password can be reset. This mitigates the account takeover vulnerability by adding an additional authentication step.
- title: Account Takeover Vulnerability
  need: Ensure secure account management by preventing unauthorized access
  context:
    - Java SE 8+
    - Web applications (Web MPA, Web SPA, API REST, etc.)
    - Java servlets used in the code
  vulnerability_id: "417"
  solution:
    language: java
    insecure_code_example:
      text: |
        @WebServlet("/passwordReset")
        public class PasswordResetServlet extends HttpServlet {
          protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            String username = request.getParameter("username");
            String newPassword = request.getParameter("newPassword");
            User user = Database.findUserByUsername(username);
            user.setPassword(newPassword);
            Database.updateUser(user);
          }
        }
      description: The servlet allows anyone to reset the password of any user, just by knowing their username. An attacker could exploit this to take over a user's account.
    steps:
      - Always validate the identity of the user when sensitive operations, like password resets, are requested. This can be done using security questions, email validation, or even two-factor authentication.
      - Avoid providing direct feedback indicating the existence of a user in the system.
    secure_code_example:
      text: |
        @WebServlet("/passwordReset")
        public class PasswordResetServlet extends HttpServlet {
          protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            String username = request.getParameter("username");
            String newPassword = request.getParameter("newPassword");
            String securityAnswer = request.getParameter("securityAnswer");

            User user = Database.findUserByUsername(username);
            if (user != null && user.getSecurityAnswer().equals(securityAnswer)) {
              user.setPassword(newPassword);
              Database.updateUser(user);
            }
            else {
              response.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid security answer.");
            }
          }
        }
      description: The updated code now requires a correct answer to a security question before a password can be reset. This mitigates the account takeover vulnerability by adding an additional authentication step.
- title: Inappropriate Coding Practices - System Exit
  need: Secure and controlled application termination
  context:
    - Java SE 8+
    - Web applications (Web MPA, Web SPA, API REST, etc.)
    - Java servlets used in the code
  vulnerability_id: "423"
  solution:
    language: java
    insecure_code_example:
      text: |
        @WebServlet("/shutdown")
        public class ShutdownServlet extends HttpServlet {
          protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            System.exit(0);
          }
        }
      description: This code shuts down the entire application if the "/shutdown" path is accessed. This is a serious security risk as it can be used by an attacker to cause a denial of service by simply accessing a particular URL.
    steps:
      - Remove any calls to System.exit() from the servlets.
      - If you need to perform any cleanup when the application is stopping, consider using the contextDestroyed() method of a ServletContextListener.
    secure_code_example:
      text: |
        public class AppLifecycleListener implements ServletContextListener {
          @Override
          public void contextDestroyed(ServletContextEvent sce) {
            // Perform cleanup here
          }

          @Override
          public void contextInitialized(ServletContextEvent sce) {
            // Perform initialization here
          }
        }
      description: This updated code uses a ServletContextListener to handle initialization and cleanup when the application starts and stops, instead of inappropriately using System.exit() in the servlet code. This ensures that the application termination can't be triggered from a HTTP request and it is controlled by the application container.
- title: Authentication Mechanism Absence or Evasion - Security Image
  need: Robust User Authentication Mechanism
  context:
    - Java SE 8+
    - Web applications (Web MPA, Web SPA, API REST, etc.)
    - Java servlets and session management used in the code
  vulnerability_id: "370"
  solution:
    language: java
    insecure_code_example:
      text: |
        @WebServlet("/login")
        public class LoginServlet extends HttpServlet {
          protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            String username = request.getParameter("username");
            String password = request.getParameter("password");
            String securityImage = request.getParameter("securityImage");

            // Incorrect way of handling security image, no actual validation is done.
            if (username != null && password != null) {
              // Authentication process...
            }
          }
        }
      description: This code reads the username, password, and security image from the request, but does not actually validate the security image. This allows an attacker to evade the security image mechanism entirely.
    steps:
      - Implement a check for the security image in the authentication process.
      - The security image must be associated with the user's account and verified on each login attempt.
    secure_code_example:
      text: |
        @WebServlet("/login")
        public class LoginServlet extends HttpServlet {
          protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            String username = request.getParameter("username");
            String password = request.getParameter("password");
            String securityImage = request.getParameter("securityImage");

            // Retrieve the expected security image for the user
            String expectedSecurityImage = getExpectedSecurityImage(username);

            // Validate the security image
            if (username != null && password != null && securityImage != null && securityImage.equals(expectedSecurityImage)) {
              // Authentication process...
            }
          }

          private String getExpectedSecurityImage(String username) {
            // Code to retrieve the expected security image for the user
            // This will be different for each application
          }
        }
      description: This updated code verifies that the security image provided in the login request matches the security image associated with the user's account, thus ensuring the security image mechanism cannot be evaded.
- title: Security Controls Bypass or Absence - Debug Protection
  need: Effective Debugging Practices
  context:
    - Java SE 8+
    - All types of applications (Web MPA, Web SPA, API REST, API GraphQL, etc.)
    - Standard Java logging practices used in the code
  vulnerability_id: "374"
  solution:
    language: java
    insecure_code_example:
      text: |
        public class UserService {
          public User getUser(String userId) {
            // Some debug log that might expose sensitive data
            System.out.println("Getting user with id: " + userId);
            User user = userDatabase.get(userId);
            System.out.println("Fetched user: " + user);
            return user;
          }
        }
      description: This code logs potentially sensitive information about a user object, including the user ID, which could be exposed if an attacker gains access to the logs.
    steps:
      - Remove debug logs or wrap them with a condition that checks if the application is in debug mode.
      - Ensure that any sensitive data, like user details, is not logged.
    secure_code_example:
      text: |
        public class UserService {
          private static final boolean DEBUG = false; // set to true only in dev environment
          public User getUser(String userId) {
            if(DEBUG) {
              System.out.println("Getting user with id: " + userId);
            }
            User user = userDatabase.get(userId);
            if(DEBUG) {
              System.out.println("Fetched user: " + user);
            }
            return user;
          }
        }
      description: This updated code wraps debug logs with a condition that checks if the application is in debug mode. It also ensures that any sensitive information, like user details, is not exposed in the logs.
- title: Inappropriate Coding Practices - Unnecessary Imports
  need: Code Optimization and Memory Management
  context:
    - Java SE 8+
    - All types of applications (Web MPA, Web SPA, API REST, API GraphQL, etc.)
    - Standard Java practices used in the code
  vulnerability_id: "379"
  solution:
    language: java
    insecure_code_example:
      text: |
        import java.util.ArrayList;
        import java.util.HashMap;
        import java.util.LinkedList;
        import java.util.Queue;

        public class ImportExample {
          private ArrayList<String> list;

          public ImportExample() {
            this.list = new ArrayList<>();
          }

          public void addToList(String item) {
            this.list.add(item);
          }
        }
      description: This code imports java.util.HashMap, java.util.LinkedList, and java.util.Queue classes which are not used, thereby unnecessarily increasing the memory footprint and load time of the application.
    steps:
      - Review all import statements to confirm they are necessary.
      - Remove any import statements for classes that are not used in the code.
      - Keep the codebase as lean as possible, which helps in improving performance.
    secure_code_example:
      text: |
        import java.util.ArrayList;

        public class ImportExample {
          private ArrayList<String> list;

          public ImportExample() {
            this.list = new ArrayList<>();
          }

          public void addToList(String item) {
            this.list.add(item);
          }
        }
      description: This updated code includes only the necessary imports. This keeps the codebase lean, improves performance, and reduces memory footprint.
- title: Insecurely Generated Token - OTP
  need: Secure OTP Generation and Validation
  context:
    - Java SE 8+
    - All types of applications (Web MPA, Web SPA, API REST, API GraphQL, etc.)
    - Standard Java practices used in the code
  vulnerability_id: "383"
  solution:
    language: java
    insecure_code_example:
      text: |
        import java.util.Random;

        public class OTPService {
          public String generateOTP() {
            Random rand = new Random();
            return String.format("%04d", rand.nextInt(10000));
          }

          // Note: This is client-side code and should not be in a server-side class
          public boolean validateOTP(String userEnteredOTP, String generatedOTP) {
            return userEnteredOTP.equals(generatedOTP);
          }
        }
      description: This code generates an OTP and validates it on the client-side, which is a vulnerability as the OTP should be generated and validated server-side.
    steps:
      - Remove the OTP generation and validation code from the client-side.
      - Generate and validate the OTP on the server-side to maintain security.
      - Use secure communication (HTTPS) to send OTP to the client.
    secure_code_example:
      text: |
        import java.util.Random;

        public class OTPService {

          // This map will store the OTP associated with a particular client.
          // This should ideally be stored in a database or some persistent storage for production use.
          private HashMap<String, String> otpData = new HashMap<>();

          public String generateOTP(String clientID) {
            Random rand = new Random();
            String otp = String.format("%04d", rand.nextInt(10000));
            otpData.put(clientID, otp);
            return otp;
          }

          public boolean validateOTP(String clientID, String userEnteredOTP) {
            String generatedOTP = otpData.get(clientID);
            return userEnteredOTP.equals(generatedOTP);
          }
        }
      description: This updated code generates and validates the OTP on the server-side. It stores the generated OTP in a HashMap with the clientID for later validation. The OTP is generated and sent to the client-side over secure communication (not shown), and the user-entered OTP is validated against the stored OTP.
- title: Inappropriate Coding Practices - Unused Properties
  need: Code Cleanliness and Optimization
  context:
    - Java SE 8+
    - All types of applications (Web MPA, Web SPA, API REST, API GraphQL, etc.)
    - Standard Java practices used in the code
  vulnerability_id: "391"
  solution:
    language: java
    insecure_code_example:
      text: |
        public class ExampleClass {
          private String usedProperty;
          private String unusedProperty; // This property is declared but never used

          public ExampleClass(String usedProperty) {
            this.usedProperty = usedProperty;
          }

          public String getUsedProperty() {
            return usedProperty;
          }
        }
      description: This code declares an unused property, which adds unnecessary complexity to the source code and may affect performance.
    steps:
      - Identify the unused properties in the code.
      - Verify that these properties are indeed not used anywhere in the code.
      - Remove these unused properties from the code.
    secure_code_example:
      text: |
        public class ExampleClass {
          private String usedProperty;

          public ExampleClass(String usedProperty) {
            this.usedProperty = usedProperty;
          }

          public String getUsedProperty() {
            return usedProperty;
          }
        }
      description: This updated code has removed the unused property, making it cleaner and potentially improving performance.
- title: Fragment Injection Vulnerability
  need: Secure Fragment Handling in Android Applications
  context:
    - Java SE 8+, Android SDK 19+
    - Android Applications
    - Android PreferenceActivity used in the code
  vulnerability_id: "398"
  solution:
    language: java
    insecure_code_example:
      text: |
        public class VulnerableActivity extends PreferenceActivity {
          @Override
          protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
          }

          @Override
          protected boolean isValidFragment(String fragmentName) {
            // This is a vulnerable practice, as any fragment can be injected
            return true;
          }
        }
      description: In the insecure code snippet, the method isValidFragment returns true for any fragment name. This allows for the possibility of fragment injection, which can be exploited by malicious actors.
    steps:
      - Override the isValidFragment method in your PreferenceActivity.
      - Implement a whitelist of trusted fragment names.
      - In the isValidFragment method, return true only if the fragment name is in the trusted whitelist.
    secure_code_example:
      text: |
        public class SecureActivity extends PreferenceActivity {
          private static final Set<String> ALLOWED_FRAGMENTS = new HashSet<>(
            Arrays.asList(
              "com.example.app.fragments.AllowedFragment1",
              "com.example.app.fragments.AllowedFragment2"
            ));

          @Override
          protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
          }

          @Override
          protected boolean isValidFragment(String fragmentName) {
            // Only allow known fragments
            return ALLOWED_FRAGMENTS.contains(fragmentName);
          }
        }
      description: In the secure code snippet, the method isValidFragment checks whether the fragment name is in a trusted whitelist before returning true. This prevents fragment injection by ensuring that only trusted fragments are allowed.
