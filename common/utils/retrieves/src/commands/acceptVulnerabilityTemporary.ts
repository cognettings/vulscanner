import _ from "lodash";
import { all, range } from "ramda";
import type { DiagnosticCollection, InputBoxValidationMessage } from "vscode";
// eslint-disable-next-line import/no-unresolved
import { InputBoxValidationSeverity, window } from "vscode";

import { acceptVulnerabilityTemporary as acceptVulnerabilityTemporaryMutation } from "@retrieves/api/vulnerabilities";
import type { VulnerabilityDiagnostic } from "@retrieves/types";
import { validDateField, validTextField } from "@retrieves/utils/validations";

const getDiagnostics = (
  retrievesDiagnostics: DiagnosticCollection
): readonly VulnerabilityDiagnostic[] | undefined => {
  const { activeTextEditor } = window;
  if (!activeTextEditor) {
    return undefined;
  }
  const fileDiagnostics: readonly VulnerabilityDiagnostic[] | undefined =
    retrievesDiagnostics.get(activeTextEditor.document.uri);

  if (!fileDiagnostics) {
    void window.showInformationMessage(
      "This line does not contain vulnerabilities"
    );

    return undefined;
  }
  if (
    range(
      activeTextEditor.selection.start.line,
      activeTextEditor.selection.end.line + 1
    ).length > 1
  ) {
    void window.showErrorMessage(
      "can only request to reattack one vulnerability at a time"
    );

    return undefined;
  }

  return fileDiagnostics;
};

const getJustification = async (): Promise<string | undefined> => {
  const justification = await window.showInputBox({
    placeHolder: "justification",
    title: "Treatment justification",
    validateInput: (message): InputBoxValidationMessage | undefined => {
      if (message.length < 10) {
        return {
          message:
            "The length of the justification must be greater than 10 characters",
          severity: InputBoxValidationSeverity.Error,
        };
      }
      if (message.length > 10000) {
        return {
          message:
            "The length of the justification must be less than 10000 characters",
          severity: InputBoxValidationSeverity.Error,
        };
      }
      const validationMessage = validTextField(message);

      if (validationMessage !== undefined) {
        return {
          message: validationMessage,
          severity: InputBoxValidationSeverity.Error,
        };
      }

      return undefined;
    },
  });

  return justification;
};

const acceptVulnerabilityTemporary = async (
  retrievesDiagnostics: DiagnosticCollection
): Promise<void> => {
  const { activeTextEditor } = window;
  if (!activeTextEditor) {
    return;
  }
  const fileDiagnostics = getDiagnostics(retrievesDiagnostics);

  if (!fileDiagnostics) {
    await window.showInformationMessage(
      "This line does not contain vulnerabilities"
    );

    return;
  }
  const diagnostics = fileDiagnostics.filter(
    (item): boolean =>
      item.source === "fluidattacks" &&
      range(
        activeTextEditor.selection.start.line,
        activeTextEditor.selection.end.line + 1
      ).includes(item.range.start.line)
  );

  const justification = await getJustification();

  const acceptanceDate = await window.showInputBox({
    placeHolder: "yyyy-mm-dd",
    title: "Temporarily accepted until",
    validateInput: (message): InputBoxValidationMessage | undefined => {
      const validationMessage = validDateField(message);

      if (validationMessage !== undefined) {
        return {
          message: validationMessage,
          severity: InputBoxValidationSeverity.Error,
        };
      }

      return undefined;
    },
  });

  if (_.isUndefined(acceptanceDate) || _.isUndefined(justification)) {
    return;
  }

  const result = await Promise.all(
    diagnostics.map(async (diagnostic): Promise<boolean> => {
      const response = await acceptVulnerabilityTemporaryMutation(
        diagnostic.findingId ?? "",
        diagnostic.vulnerabilityId ?? "",
        acceptanceDate,
        justification,
        "ACCEPTED"
      );

      if (!response.updateVulnerabilitiesTreatment.success) {
        await window.showWarningMessage(
          response.updateVulnerabilitiesTreatment.message ??
            "Failed to to update vulnerability treatment"
        );
      }

      return response.updateVulnerabilitiesTreatment.success;
    })
  );

  if (all((item): boolean => item, result)) {
    void window.showInformationMessage("Treatment updated successfully");
  }
};

export { acceptVulnerabilityTemporary };
